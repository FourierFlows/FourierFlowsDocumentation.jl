var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"S.¬†A.¬†Orszag. On the elimination of aliasing in finite-difference schemes by filtering high-wavenumber components. Journal¬†of¬†the¬†Atmospheric¬†Sciences 28, 1074‚Äì107 (1971).\n\n\n\nA.¬†K.¬†Kassam and L.¬†N.¬†Trefethen. Fourth-order time-stepping for stiff PDEs. SIAM¬†Journal¬†on¬†Scientific¬†Computing 26, 1214‚Äì1233 (2005).\n\n\n\nC.¬†Canuto, M.¬†Y.¬†Hussaini, A.¬†Quarteroni and T.¬†A.¬†Zang. Spectral methods in fluid dynamics (Springer-Verlag, 1987).\n\n\n\nJ.¬†H.¬†LaCasce. Baroclinic vortices over a sloping bottom. Ph.D. Thesis, Massachusetts Institute of Technology (1996).\n\n\n\nB.¬†K.¬†Arbic and G.¬†R.¬†Flierl. Effects of mean flow direction on energy, isotropy, and coherence of baroclinically unstable beta-plane geostrophic turbulence. Journal¬†of¬†Physical¬†Oceanography 34, 77‚Äì93 (2004).\n\n\n\nM.¬†H.¬†Carpenter and C.¬†A.¬†Kennedy. Fourth-order 2N-storage Runge‚ÄìKutta schemes. Technical Report¬†NASA TM-109112 (National Aeronautics and Space Administration, NASA Langley Research Center, Hampton, VA, 1994).\n\n\n\n","category":"page"},{"location":"contributing/#Contributors-Guide","page":"Contributor's guide","title":"Contributors Guide","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"This is a short guide for potential FourierFlows.jl contributors.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Please feel free to ask us questions and chat, either by raising an issue or starting a discussion.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"We follow the ColPrac guide for collaborative practices.  New contributors should make sure to read that guide.","category":"page"},{"location":"contributing/#What-can-I-do?","page":"Contributor's guide","title":"What can I do?","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Tackle an existing issue.\nImprove documentation, docstrings, or comments if you found something is hard to use.\nImplement a new feature (e.g., a new diagnostic into a module).","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"If you're interested in working on something, let us know by commenting on an existing issue  or by opening a new issue. This is to make sure no one else is working on the same issue and  so we can help and guide you in case there is anything you need to know beforehand.","category":"page"},{"location":"contributing/#Ground-Rules","page":"Contributor's guide","title":"Ground Rules","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Each pull request should consist of a logical collection of changes. You can include multiple bug fixes in a single pull request, but they should be related. For unrelated changes, please submit multiple pull requests.\nDo not commit changes to files that are irrelevant to your feature or bugfix (e.g., .gitignore).\nBe willing to accept criticism and work on improving your code; we don't want to break other users' code, so care must be taken not to introduce bugs. We discuss pull requests and keep working on them until we believe we've done a good job.\nBe aware that the pull request review process is not immediate, and is generally proportional to the size of the pull request.","category":"page"},{"location":"contributing/#Reporting-a-bug","page":"Contributor's guide","title":"Reporting a bug","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"The easiest way to get involved is to report issues you encounter when using FourierFlows.jl  or by requesting something you think is missing.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Head over to the issues page.\nSearch to see if your issue already exists or has even been solved previously.\nIf you indeed have a new issue or request, click the \"New Issue\" button.\nPlease be as specific as possible. Include the version of the code you were using, as well as what operating system you are running. The output of Julia's versioninfo() and ] status is helpful to include. If possible, include complete, minimal example code that reproduces the problem.","category":"page"},{"location":"contributing/#Setting-up-your-development-environment","page":"Contributor's guide","title":"Setting up your development environment","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Install Julia on your system.\nInstall git on your system if it is not already there (install XCode command line tools on a Mac or git bash on Windows).\nLogin to your GitHub account and make a fork of the FourierFlows.jl repository by clicking the \"Fork\" button.\nClone your fork of the FourierFlows.jl repository (in terminal on Mac/Linux or git shell/ GUI on Windows) in the location you'd like to keep it.\ngit clone https://github.com/your-user-name/FourierFlows.jl.git\nNavigate to that folder in the terminal or in Anaconda Prompt if you're on Windows.\nConnect your repository to the upstream (main project).\ngit remote add FourierFlows https://github.com/FourierFlows/FourierFlows.jl.git\nCreate the development environment by opening Julia via julia --project then typing in ] instantiate. This will install all the dependencies in the Project.toml file.\nYou can test to make sure FourierFlows.jl works by typing in ] test. This will run all the tests (this can take a while). In an ideal world you should run the tests on a machine with a GPU capability but if that's not a possibility that is available to you then don't  worry ‚Äì simply comment in a PR that you didn't test on GPU.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Your development environment is now ready!","category":"page"},{"location":"contributing/#Pull-Requests","page":"Contributor's guide","title":"Pull Requests","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Changes and contributions should be made via GitHub pull requests against the master branch.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"When you're done making changes, commit the changes you made. Chris Beams has written  a guide on how to write good commit messages.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"When you think your changes are ready to be merged into the main repository, push to your fork and submit a pull request.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Working on your first Pull Request? You can learn how from this free video series How to Contribute to an Open Source Project on GitHub, Aaron Meurer's tutorial on the git workflow,  or the guide ‚ÄúHow to Contribute to Open Source\".","category":"page"},{"location":"contributing/#Documentation","page":"Contributor's guide","title":"Documentation","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"All PRs that introduce new features or new modules should be accompanied with appropriate  docstrings and documentation. Writing documentation strings is really important to make sure  others use your functionality properly. Didn't write new functions? That's fine, but be sure  that the documentation for the code you touched is still in great shape. It is not uncommon  to find some strange wording or clarification that you can take care of while you are here.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"We encourage using unicode characters  when writing docstrings, e.g., use Œ± instead of \\alpha. This makes the rendering of the  docstrings in the Documentation and in the Julia REPL's help?> mode as similar as possible.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"You can preview how the Documentation will look like after merging by building the documentation  locally. To do that, from the main directory of your local repository call","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"julia --project=docs/ -e 'using Pkg; Pkg.develop(PackageSpec(path=pwd())); Pkg.instantiate()'\njulia --project=docs/ docs/make.jl","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"and then open docs/build/index.html in your favorite browser.","category":"page"},{"location":"contributing/#Credits","page":"Contributor's guide","title":"Credits","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"This contributor's guide is heavily based on the MetPy contributor's guide  and on its \"cover\" made by Oceananigans.jl.","category":"page"},{"location":"basics/#Code-Basics","page":"Code Basics","title":"Code Basics","text":"","category":"section"},{"location":"basics/","page":"Code Basics","title":"Code Basics","text":"The code solves partial differential equations of the form","category":"page"},{"location":"basics/","page":"Code Basics","title":"Code Basics","text":" partial_t u = Lu + N(u)  ","category":"page"},{"location":"basics/","page":"Code Basics","title":"Code Basics","text":"using Fourier transforms on periodic domains. Above, u(bmx t) is the state variable.  On the right-hand-side, term L u is the 'linear' part of the equation. The term  N(u) is, in general, a 'nonlinear' part.","category":"page"},{"location":"basics/","page":"Code Basics","title":"Code Basics","text":"In FourierFlows.jl, L u is specified by the various modules by prescribing the linear operator L as an array of the same dimension as u. The nonlinear term  N(u) is specified via a function that takes u as its argument.","category":"page"},{"location":"basics/","page":"Code Basics","title":"Code Basics","text":"Boundary conditions in all spatial dimensions are periodic. That allows us to expand all  variables using a Fourier decomposition. For example, if u depends only in one spatial  dimension, x, defined over the domain x in 0 L_x, then:","category":"page"},{"location":"basics/","page":"Code Basics","title":"Code Basics","text":"u(x t) = sum_k_x hatu(k_x t)  e^i k_x x  ","category":"page"},{"location":"basics/","page":"Code Basics","title":"Code Basics","text":"where wavenumbers k_x take the values tfrac2piL_x0pm 1pm 2dots. When we  further consider that x takes discrete values over 0 L_x, e.g., x_j, j = 0 1 dots n_x, then only n_x wavenumbers are independent. By denoting u_j(t) equiv u(x_j t)  and hatu_k(t) equiv hatu(tfrac2piL_x k t) with k an integer, then the  Fourier sum above truncates to:","category":"page"},{"location":"basics/","page":"Code Basics","title":"Code Basics","text":"u_j(t) = sum_k=-n_x2^n_x2-1 hatu_k(t)e^2pi i k x_j  L_x  ","category":"page"},{"location":"basics/","page":"Code Basics","title":"Code Basics","text":"(We assumed here that n_x is even.)","category":"page"},{"location":"basics/","page":"Code Basics","title":"Code Basics","text":"Applying the Fourier transform as above, the partial differential equation transforms to:","category":"page"},{"location":"basics/","page":"Code Basics","title":"Code Basics","text":" partial_t hatu = hatL hatu + widehat N(u)   ","category":"page"},{"location":"basics/","page":"Code Basics","title":"Code Basics","text":"where hatL above denotes the linear operator in Fourier space.","category":"page"},{"location":"basics/","page":"Code Basics","title":"Code Basics","text":"Equations are oftentimes time-stepped forward in Fourier space. Doing so, hatu_k(t)  becomes now our state variable, i.e., the array with all Fourier coefficients of the solution  u. Although time-stepping in Fourier space is by no means a restriction of the code, it  usually enhances performance because it requires less transformations back and forth from  physical to Fourier space and vice versa.","category":"page"},{"location":"aliasing/#aliasing","page":"Aliasing","title":"Aliasing","text":"","category":"section"},{"location":"aliasing/","page":"Aliasing","title":"Aliasing","text":"using FourierFlows\nusing CairoMakie\nset_theme!(Theme(linewidth = 3, fontsize = 20))","category":"page"},{"location":"aliasing/","page":"Aliasing","title":"Aliasing","text":"In pseudospectral methods, when computing nonlinear terms then aliasing errors come into play.  These aliasing errors originate from the discrete nature of the grid and, specifically, the  restriction that a grid discretized with n_x points can only resolve up to n_x  wavenumbers in Fourier space. ","category":"page"},{"location":"aliasing/","page":"Aliasing","title":"Aliasing","text":"Consider a grid with a total of n_x points. Both harmonics e^2pi i k x  L_x and  e^2pi i (k+n_x) x  L_x, with k an integer, are indistinguishable when evaluated on the discrete grid-points of this grid. When we compute nonlinear terms in physical space (products of various fields), we may end up with terms that project on harmonics with wavenumber beyond the maximum wavenumber that can be resolved by our grid. In that case, those wavenumbers  will be erroneously projected onto some lower wavenumber modes that fit our domain.","category":"page"},{"location":"aliasing/","page":"Aliasing","title":"Aliasing","text":"Take, for example, functions cos(4x) and cos(6x) and let's see how they are represented  on a grid x in -œÄ œÄ) with n_x = 10 grid points.","category":"page"},{"location":"aliasing/","page":"Aliasing","title":"Aliasing","text":"using CairoMakie\nCairoMakie.activate!(type = \"svg\")","category":"page"},{"location":"aliasing/","page":"Aliasing","title":"Aliasing","text":"using FourierFlows, CairoMakie\n\nnx, Lx = 10, 2œÄ\ngrid = OneDGrid(; nx, Lx)\n\nf1(x) = cos(4x)\nf2(x) = cos(6x)\n\nx = grid.x\n\nfig = Figure()\nax = Axis(fig[1, 1], xlabel = \"x\", limits = ((-Lx/2, Lx/2), (-1.6, 1.6)))\n\nlines!(ax, range(-Lx/2, Lx/2, length=200), f1;\n       color = (:steelblue, 0.3), label = \"cos(4x)\")\nlines!(ax, range(-Lx/2, Lx/2, length=200), f2;\n       color = (:salmon, 0.3), label = \"cos(6x)\")\n\nscatter!(ax, x, f1.(x);\n         markersize = 12, color = (:steelblue, 0.9), label = \"cos(4x)\")\nscatter!(ax, x, f2.(x);\n         markersize = 24, marker = :star5, color = (:salmon, 0.9), label = \"cos(6x)\")\n\naxislegend(merge = true)\n\ncurrent_figure() # hide","category":"page"},{"location":"aliasing/","page":"Aliasing","title":"Aliasing","text":"The take home message is that on this particular grid we cannot distinguish harmonics with  wavenumbers 4 and 6. An attempt to represent harmonics with wavenumber 6 on this grid leads to  aliasing errors. For example, say that we are solving an equation and at some point we compute  the product cos(2x) cos(4x). The result should be frac12 cos(2x) + frac12 cos(6x),  but on this grid cos(6x) is indistinguishable from cos(4x) and, therefore, what we compute will be indistinguishable from frac12 cos(2x) + frac12 cos(4x)!","category":"page"},{"location":"aliasing/","page":"Aliasing","title":"Aliasing","text":"To avoid aliasing errors we either (i) discard some of the wavenumber components in Fourier  space from our fields before we transform to physical space, or (ii) pad our fields with Fourier  components with zero power that correspond to higher wavenumbers than those resolved by the grid  before transforming to physical space. This way, the aliasing errors, which will involve the  higher wavenumbers, will be either (i) zero-ed out or (ii) only come about for wavenumbers  beyond what our grid can resolve anyway. In FourierFlows.jl, the former dealiasing scheme is  implemented.","category":"page"},{"location":"aliasing/","page":"Aliasing","title":"Aliasing","text":"info: De-aliasing scheme\nFourierFlows.jl currently implements dealiasing by zeroing out the highest-aliased_fraction  wavenumber components on a grid.","category":"page"},{"location":"aliasing/","page":"Aliasing","title":"Aliasing","text":"The number of wavenumber components that we need to zero-out to be sure the no aliasing errors  infiltrate our solution depends on the order of the nonlinearities. For example, for quadratic  nonlinearities, one expects that we need to discard the highest-1/2 of the wavenumber components.  This way, when computing the product of two fields we won't have anything that projects onto harmonics with wavenumbers beyond those that our grid is able to resolve and, therefore, no  aliasing errors.","category":"page"},{"location":"aliasing/","page":"Aliasing","title":"Aliasing","text":"The above-mentioned 1/2-rule for dealiasing for quadratic nonlinearities is, however, not the  most efficient. [1] pointed out that for quadratic nonlirearities, simply only discarding the highest-1/3 of wavenumber components is enough to save us from aliasing errors. To be fair, with Orszag's so-called 2/3-rule for dealiasing, still some aliasing errors occur, but those  errors only occur to the higher-1/3 wavenumber components that will be zero-ed out at the next time step, when we next dealias our solution anyway.","category":"page"},{"location":"aliasing/","page":"Aliasing","title":"Aliasing","text":"When constructing a grid we can specify the aliased_fraction parameter. By default, this is  set to 13, appropriate for quadratic nonlinearities. Then dealias!(fh, grid) will zero-out  the highest-aliased_fraction wavenumber components of fh. ","category":"page"},{"location":"aliasing/","page":"Aliasing","title":"Aliasing","text":"FourierFlows.dealias!","category":"page"},{"location":"aliasing/#FourierFlows.dealias!","page":"Aliasing","title":"FourierFlows.dealias!","text":"dealias!(fh, grid)\n\nDealias array fh on the grid based on the grids's aliased_fraction.\n\n\n\n\n\n","category":"function"},{"location":"aliasing/","page":"Aliasing","title":"Aliasing","text":"If we construct a grid with aliased_fraction = 0, e.g.,","category":"page"},{"location":"aliasing/","page":"Aliasing","title":"Aliasing","text":"grid_nodealias = OneDGrid(; nx, Lx, aliased_fraction=0)","category":"page"},{"location":"aliasing/","page":"Aliasing","title":"Aliasing","text":"then dealias!(fh, grid_nodealias) will have no effect whatsoever on fh.","category":"page"},{"location":"output/#Output","page":"Output","title":"Output","text":"","category":"section"},{"location":"output/","page":"Output","title":"Output","text":"To save output we use Output. Let's see how we can use the example developed in Problem and Diagnostics sections to demonstrate how we can save some output to disk and then load it.","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"DocTestSetup = quote\n    using FourierFlows\n    using LinearAlgebra: mul!, ldiv!\n    nx, Lx = 32, 2.0\n    grid = OneDGrid(; nx, Lx)\n    struct Params <: AbstractParams\n    Œ± :: Float64\n    end\n    params = Params(0.1)\n    struct Vars <: AbstractVars\n        u :: Array{Float64,1}\n    uh :: Array{Complex{Float64}, 1}\n    end\n    vars = Vars(zeros(Float64, (grid.nx,)), zeros(Complex{Float64}, (grid.nkr,)))\n    L = - params.Œ± * ones(grid.nkr)\n    function calcN!(N, sol, t, clock, vars, params, grid)\n        @. N = 0\n        return nothing\n    end\n    equation = FourierFlows.Equation(L, calcN!, grid)\n    stepper, dt = \"ForwardEuler\", 0.02\n    prob = FourierFlows.Problem(equation, stepper, dt, grid, vars, params)\n    u0 = @. cos(œÄ * grid.x)\n    mul!(prob.sol, grid.rfftplan, u0)\n    function energy(prob)\n        ldiv!(prob.vars.u, grid.rfftplan, prob.sol)\n        return sum(prob.vars.u.^2) * prob.grid.dx\n    end\n    E = Diagnostic(energy, prob, freq=2, nsteps=200)\n    filepath = \".\"\n    filename = joinpath(filepath, \"simplestpde.jld2\")\n    get_uh(prob) = prob.sol\nend","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"using FourierFlows\nusing CairoMakie\nCairoMakie.activate!(type = \"svg\")\nset_theme!(Theme(linewidth = 3, fontsize = 20))\nusing LinearAlgebra: mul!, ldiv!\n\nnx, Lx = 32, 2.0\ngrid = OneDGrid(; nx, Lx)\n\nstruct Params <: AbstractParams\n  Œ± :: Float64\nend\n\nparams = Params(0.1)\n\nstruct Vars <: AbstractVars\n     u :: Array{Float64, 1}\n    uh :: Array{Complex{Float64}, 1}\nend\n\nvars = Vars(zeros(Float64, (grid.nx,)), zeros(Complex{Float64}, (grid.nkr,)))\n\nL = - params.Œ± * ones(grid.nkr)\n\nfunction calcN!(N, sol, t, clock, vars, params, grid)\n    @. N = 0\n\n    return nothing\nend\n\nequation = FourierFlows.Equation(L, calcN!, grid)\n\nstepper, dt = \"ForwardEuler\", 0.02\n\nprob = FourierFlows.Problem(equation, stepper, dt, grid, vars, params)\n\nu0 = @. cos(œÄ * grid.x)\n\nmul!(prob.sol, grid.rfftplan, u0)\n\nfunction energy(prob)\n    ldiv!(prob.vars.u, grid.rfftplan, prob.sol)\n    return sum(prob.vars.u.^2) * prob.grid.dx\nend\n\nE = Diagnostic(energy, prob, freq=2, nsteps=200)","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"After we have created the problem (prob) and the energy diagnostic (E), we can construct an Output. We first choose where we'd like to output the .jld2 file(s):","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"filepath = \".\"\nfilename = joinpath(filepath, \"simplestpde.jld2\")","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"and the construct the Output. To do so, we provide tuples of fields that we want to output and a function what takes prob as its argument and returns the corresponding value of that field. For this example, let's save the energy E and the state vector sol.","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"get_uh(prob) = prob.sol\n\nout = Output(prob, filename, (:uh, get_uh), (:E, energy))","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"get_uh(prob) = prob.sol #hide\n\nout = Output(prob, filename, (:uh, get_uh), (:E, energy)) #hide","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"Note that we haven't saved anything to disk yet!","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"By calling saveproblem","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"saveproblem(out)","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"we write all certain aspects of the problem on the .jld2 file. For example, doing so saves the grid parameters (Lx, nx, ...), everything in prob.params, the the linear operator and its attributes from prob.eqn, and the time-step (prob.clock.dt). All these are very useful in case we'd like to re-create the problem.","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"Let's open the file and have a quick look what's been written there.","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"using JLD2\nfile = jldopen(out.path)","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"Accessing the saved values is done using usual HDF5 way, e.g.,","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"file[\"grid/nx\"]","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"Let's now close the file and move on with our demonstration.","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"close(file)","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"Now we can start saving our output fields. We do so via saveoutput, which will go through the list of fields we provided to Output, call the functions that compute the fields, and write their results on disk.","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"saveoutput(out)","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"The output fields are saved under \"snapshots\" group, e.g.,","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"file = jldopen(out.path)\nfile[\"snapshots\"]","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"Let's close the file again.","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"close(file)","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"We can now time-step the problem forward and save the output files on disk every so often.","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"for _ in 1:40\n    stepforward!(prob, E, 5)\n    saveoutput(out)\nend","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"All right! Now we have simulated 200 time-steps saving output every 5 time-steps.","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"Let's see now how we can load the output we saved in the .jld2 file and visualize it.","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"We load the .jld2 file and extract the saved iterations.","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"file = jldopen(out.path)\n\niterations = parse.(Int, keys(file[\"snapshots/t\"]))","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"Then we can construct a vector with all saved times and all saved values for energy.","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"times = [file[\"snapshots/t/$iteration\"] for iteration in iterations]\n\nenergies = [file[\"snapshots/E/$iteration\"] for iteration in iterations]\n\nnothing #hide","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"and plot:","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"using CairoMakie\n\nlines(times, energies; axis = (xlabel = \"t\", ylabel = \"energy\"))\n\ncurrent_figure() # hide","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"Lastly, let's load the saved uh fields, process them (get u by convert to physical space), and animate them.","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"We use Makie's Observable to animate the data. To dive into how Observables work we refer to Makie.jl's Documentation.","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"using CairoMakie, Printf\n\nnx = file[\"grid/nx\"]\n x = file[\"grid/x\"]\n\nn = Observable(1)\n\nu = @lift irfft(file[string(\"snapshots/uh/\", iterations[$n])], nx)\ntitle = @lift @sprintf(\"u(x, t=%1.2f)\", file[string(\"snapshots/t/\", iterations[$n])])\n\nfig = Figure()\nax = Axis(fig[1, 1]; xlabel = \"x\", title)\nscatterlines!(ax, x, u; markersize = 14)\n\nframes = 1:length(iterations)\n\nrecord(fig, \"animation.mp4\", frames, framerate=16) do i\n    n[] = i\nend","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"(Image: )","category":"page"},{"location":"installation_instructions/#Installation-instructions","page":"Installation Instructions","title":"Installation instructions","text":"","category":"section"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"To install the latest version of FourierFlows.jl use the Julia's built-in package manager (accessed by pressing ] in the Julia REPL command prompt):","category":"page"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"julia> ]\n(v1.6) pkg> add FourierFlows","category":"page"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"We recommend installing FourierFlows.jl with the built-in Julia package manager, because this installs a stable, tagged release. Later, you can update FourierFlows.jl to the latest tagged release again via the package manager by","category":"page"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"(v1.6) pkg> update FourierFlows","category":"page"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"Note that some releases might induce breaking changes to certain modules. If after anything happens or your code stops working, please open an issue  or start a discussion. We're more than happy to help with getting your simulations up and running.","category":"page"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"warn: Use Julia 1.6 or newer\nThe latest FourierFlows.jl requires at least Julia v1.6 (the current long-term-release). Installing FourierFlows with an older version of Julia will install an older version of FourierFlows.jl (the latest version compatible with your version of Julia).","category":"page"},{"location":"diagnostics/#diagnostics_docs","page":"Diagnostics","title":"Diagnostics","text":"","category":"section"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"We can add diagnostics to a FourierFlows's problem using Diagnostic functionality.","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"DocTestSetup = quote\n    using FourierFlows\n    using LinearAlgebra: mul!, ldiv!\n    nx, Lx = 32, 2.0\n    grid = OneDGrid(; nx, Lx)\n    struct Params <: AbstractParams\n    Œ± :: Float64\n    end\n    params = Params(0.1)\n    struct Vars <: AbstractVars\n        u :: Array{Float64,1}\n    uh :: Array{Complex{Float64}, 1}\n    end\n    vars = Vars(zeros(Float64, (grid.nx,)), zeros(Complex{Float64}, (grid.nkr,)))\n    L = - params.Œ± * ones(grid.nkr)\n    function calcN!(N, sol, t, clock, vars, params, grid)\n    @. N = 0\n    return nothing\n    end\n    equation = FourierFlows.Equation(L, calcN!, grid)\n    stepper, dt = \"ForwardEuler\", 0.02\n    prob = FourierFlows.Problem(equation, stepper, dt, grid, vars, params)\n    u0 = @. cos(œÄ * grid.x)\n    mul!(prob.sol, grid.rfftplan, u0)\n    function energy(prob)\n        ldiv!(prob.vars.u, grid.rfftplan, prob.sol)\n        return sum(prob.vars.u.^2) * prob.grid.dx\n    end\nend","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"using FourierFlows\nusing CairoMakie\nCairoMakie.activate!(type = \"svg\")\nset_theme!(Theme(linewidth = 3, fontsize = 20))\n\nusing LinearAlgebra: mul!\n\nnx, Lx = 32, 2.0\ngrid = OneDGrid(; nx, Lx)\n\nstruct Params <: AbstractParams\n  Œ± :: Float64\nend\n\nparams = Params(0.1)\n\nstruct Vars <: AbstractVars\n    u :: Array{Float64,1}\n   uh :: Array{Complex{Float64}, 1}\nend\n\nvars = Vars(zeros(Float64, (grid.nx,)), zeros(Complex{Float64}, (grid.nkr,)))\n\nL = - params.Œ± * ones(grid.nkr)\n\nfunction calcN!(N, sol, t, clock, vars, params, grid)\n  @. N = 0\n  \n  return nothing\nend\n\nequation = FourierFlows.Equation(L, calcN!, grid)\n\nstepper, dt = \"ForwardEuler\", 0.02\n\nprob = FourierFlows.Problem(equation, stepper, dt, grid, vars, params)\n\nu0 = @. cos(œÄ * grid.x)\n\nmul!(prob.sol, grid.rfftplan, u0)","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"To demonstrate how we add diagnostics to a PDE problem, let's try to add one to the simple PDE problem we constructed in the Problem section. For example, say we'd like to add a diagnostic we refer to as the \"energy\" and which we define to be:","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"E = int u^2  mathrmd x ","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"After we have constructed the problem (prob) (see Problem section), we then create a function that takes prob as its argument returns the diagnostic:","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"using LinearAlgebra: ldiv!\n\nfunction energy(prob)\n    ldiv!(prob.vars.u, grid.rfftplan, prob.sol)\n\n    return sum(prob.vars.u.^2) * prob.grid.dx\nend\n\nnothing #hide","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"and then we create a Diagnostic using the Diagnostic constructor. Say we want to save energy every 2 time-steps, then:","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"E = Diagnostic(energy, prob, freq=2, nsteps=200)","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"E = Diagnostic(energy, prob, freq=2, nsteps=200) #hide","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"Now, when we step forward the problem we provide the diagnostic as the second positional  argument in stepforward!:","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"stepforward!(prob, E, 200)","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"Doing so, the diagnostic is computed and saved at the appropriate frequency (prescribed by E.freq).","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"info: Multiple diagnostics\nIf we want to include multiple diagnostics we can gather all of them in an array, e.g.,diag1 = Diagnostic(foo, prob)\ndiag2 = Diagnostic(bar, prob)\n\nstepforward!(prob, [diag1, diag2], 1)","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"The times that the diagnostic was saved are gathered in E.t. Thus, we can easily plot the energy time-series, e.g., ","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"using CairoMakie\n\nlines(E.t, E.data, axis = (xlabel = \"time\", ylabel = \"energy\"))\n\ncurrent_figure() # hide","category":"page"},{"location":"library/outline/#Library-Outline","page":"Contents","title":"Library Outline","text":"","category":"section"},{"location":"library/outline/","page":"Contents","title":"Contents","text":"Pages = [\"public.md\", \"internals.md\", \"function_index.md\"]","category":"page"},{"location":"library/internals/#Private-types-and-functions","page":"Private","title":"Private types and functions","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Documentation for FourierFlows.jl's internal interface.","category":"page"},{"location":"library/internals/#FourierFlows","page":"Private","title":"FourierFlows","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [FourierFlows]\nPublic  = false\nPages   = [\"FourierFlows.jl\"]","category":"page"},{"location":"library/internals/#FourierFlows.AbstractDiagnostic","page":"Private","title":"FourierFlows.AbstractDiagnostic","text":"Abstract supertype for diagnostics.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#Problem","page":"Private","title":"Problem","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [FourierFlows]\nPublic  = false\nPages   = [\"problem.jl\"]","category":"page"},{"location":"library/internals/#FourierFlows.Clock","page":"Private","title":"FourierFlows.Clock","text":"mutable struct Clock{T<:AbstractFloat}\n\nRepresents the clock of a problem.\n\ndt::AbstractFloat: the time-step\nt::AbstractFloat: the time\nstep::Int64: the step number\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#FourierFlows.EmptyParams","page":"Private","title":"FourierFlows.EmptyParams","text":"struct EmptyParams <: AbstractParams\n\nA placeholder struct for parameters.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#FourierFlows.EmptyVars","page":"Private","title":"FourierFlows.EmptyVars","text":"struct EmptyVars <: AbstractVars\n\nA placeholder struct for variables.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#FourierFlows.Equation","page":"Private","title":"FourierFlows.Equation","text":"struct Equation{T, TL, G<:AbstractFloat}\n\nThe equation to be solved ‚àÇu/‚àÇt = L * u + N(u). Array L includes the coefficients of the linear term L * u and calcN! is a function which computes the nonlinear term N(u). The struct also includes the problem's grid and the float type of the state vector (and consequently of N(u)).\n\nL::Any: array with coefficient for the linear part of the equation\ncalcN!::Function: function that computes the nonlinear part of the equation\ngrid::AbstractGrid{G} where G<:AbstractFloat: the grid\ndims::Tuple: the dimensions of L\nT::Any: the float type for the state vector\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#FourierFlows.Equation-Union{Tuple{G}, Tuple{Any, Any, AbstractGrid{G}}} where G","page":"Private","title":"FourierFlows.Equation","text":"Equation(L, calcN!, grid; dims=supersize(L), T=nothing)\n\nThe equation constructor from the array L of the coefficients of the linear term, the function  calcN! that computes the nonlinear term and the grid for the problem.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#FourierFlows.Problem","page":"Private","title":"FourierFlows.Problem","text":"struct Problem{T, A<:AbstractArray, Tg<:AbstractFloat, TL}\n\nA problem that represents a partial differential equation.\n\nsol::AbstractArray: the state vector\nclock::FourierFlows.Clock: the problem's\neqn::FourierFlows.Equation{T, TL, Tg} where {T, Tg<:AbstractFloat, TL}: the equation\ngrid::AbstractGrid{Tg} where Tg<:AbstractFloat: the grid\nvars::AbstractVars: the variables\nparams::AbstractParams: the parameters\ntimestepper::AbstractTimeStepper{A} where A<:AbstractArray: the timestepper\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#FourierFlows.Problem-Union{Tuple{T}, Tuple{FourierFlows.Equation, Any, Any, AbstractGrid{T}}, Tuple{FourierFlows.Equation, Any, Any, AbstractGrid{T}, Any}, Tuple{FourierFlows.Equation, Any, Any, AbstractGrid{T}, Any, Any}} where T","page":"Private","title":"FourierFlows.Problem","text":"Problem(eqn::Equation, stepper, dt, grid::AbstractGrid{T}, \n        vars=EmptyVars, params=EmptyParams; stepperkwargs...) where T\n\nConstruct a Problem for equation eqn using the timestepper with timestep  dt, on grid. The device is inferred from the grid. Optionally, use the keyword arguments to provide variables with vars and parameters with params. The stepperkwargs are passed on to the time-stepper constructor.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#Domain","page":"Private","title":"Domain","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [FourierFlows]\nPublic  = false\nPages   = [\"domains.jl\"]","category":"page"},{"location":"library/internals/#FourierFlows.getaliasedwavenumbers-Tuple{Any, Any, Any}","page":"Private","title":"FourierFlows.getaliasedwavenumbers","text":"getaliasedwavenumbers(nk, nkr, aliased_fraction)\n\nReturn the top aliased_fraction highest wavenumbers, both for and real FFTs, kalias and  kralias respectively. For example, aliased_fraction = 1/3 should return the indices of the  top-most 1/6-th (in absolute value) for both positive and negative wavenumbers (i.e., 1/3 total)  that should be set to zero after performing an FFT. \n\n\n\n\n\n","category":"method"},{"location":"library/internals/#FourierFlows.makefilter-Tuple{Array}","page":"Private","title":"FourierFlows.makefilter","text":"makefilter(K; order=4, innerK=2/3, outerK=1, tol=1e-15)\n\nReturn a filter acting on the non-dimensional wavenumber K. For a one-dimensional grid, the non-dimensional wavenumber K is\n\nK = k * dx / œÄ\n\nand thus take values in -1 1.\n\nFor K ‚â§ innerK the filter is inactive, i.e., equal to 1. For K > innerK, the filter decays exponentially to remove high-wavenumber content from  the solution, i.e.,\n\nfilter(K) = exp(- decay * (K - innerK)^order)\n\nFor a given order, the decay rate is determined so that the filter value at the outer wavenumber outerK is tol, where tol is a small number, close to machine precision.\n\ndecay = - log(tol) / (outerK - innerK)^order\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#Utilities","page":"Private","title":"Utilities","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [FourierFlows]\nPublic  = false\nPages   = [\"utils.jl\"]","category":"page"},{"location":"library/internals/#FourierFlows.jacobian-Tuple{Any, Any, TwoDGrid}","page":"Private","title":"FourierFlows.jacobian","text":"jacobian(a, b, grid)\n\nReturn the Jacobian of a and b on grid.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#FourierFlows.jacobianh-Tuple{Any, Any, TwoDGrid}","page":"Private","title":"FourierFlows.jacobianh","text":"jacobianh(a, b, grid)\n\nReturn the Fourier transform of the Jacobian of a and b on grid.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#FourierFlows.on_grid-Union{Tuple{T}, Tuple{Function, OneDGrid{T}}} where T","page":"Private","title":"FourierFlows.on_grid","text":"on_grid(func, grid)\n\nReturn an array, of the type compatible with the device that the grid lives on, that contains the values of function func evaluated on the grid.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#FourierFlows.parsevalsum-Tuple{Any, TwoDGrid}","page":"Private","title":"FourierFlows.parsevalsum","text":"parsevalsum(uh, grid)\n\nReturn the real part of the sum of uh on the grid. For example on a 2D grid, parsevalsum returns\n\n‚Ñú  sum_ùê§ u_ùê§ L_x L_y  \n\n\nwhere u_ùê§ = uh  (n_x e^i ùê§  ùê±‚ÇÄ). The elements of the vector ùê±‚ÇÄ are the left-most position in each direction, e.g., for a 2D grid (grid.x[1], grid.y[1]).\n\nWhen the input uh comes from a real-FFT transform, parsevalsum takes care to count the contribution from certain k-modes twice.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#FourierFlows.parsevalsum2-Tuple{Any, TwoDGrid}","page":"Private","title":"FourierFlows.parsevalsum2","text":"parsevalsum2(uh, grid)\n\nReturn the sum of |uh|¬≤ on the grid, which is equal to the domain integral of u¬≤. For example on a 2D grid, parsevalsum2 returns\n\nsum_ùê§ u_ùê§¬≤ L_x L_y = iint u¬≤ ùñΩx ùñΩy \n\nwhere u_ùê§ = uh  (n_x e^i ùê§  ùê±‚ÇÄ). The elements of the vector ùê±‚ÇÄ are the left-most position in each direction, e.g., for a 2D grid (grid.x[1], grid.y[1]).\n\nWhen the input uh comes from a real-FFT transform, parsevalsum2 takes care to count the contribution from certain k-modes twice.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#FourierFlows.radialspectrum-Tuple{Any, TwoDGrid}","page":"Private","title":"FourierFlows.radialspectrum","text":"radialspectrum(fh, grid; n=nothing, m=nothing, refinement=2)\n\nReturn the radial spectrum of fh. fh lives on Cartesian wavenumber grid (k l). To  compute the radial spectrum, we first interpolate f(k l) onto a radial wavenumber grid  (œÅ Œ∏), where œÅ¬≤ = k¬≤ + l¬≤ and Œ∏ = arctan(l  k). Note here that  f = fh  (n_x e^i ùê§  ùê±‚ÇÄ). The elements of the vector ùê±‚ÇÄ are the left-most position in each direction, e.g., for a 2D grid (grid.x[1], grid.y[1]).\n\nAfter interpolation, we integrate f over angles Œ∏ to get fœÅ,\n\n  f_œÅ = int f(œÅ Œ∏) œÅ ùñΩœÅ ùñΩŒ∏ \n\nThe resolution (n, m) for the polar wavenumber grid is n = refinement * maximum(grid.nk, grid.nl),  m = refinement * maximum(grid.nk, grid.nl), where refinement = 2 by default. If fh is in conjugate symmetric form then only the upper-half plane in Œ∏ is represented on the polar grid.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#Diagnostics","page":"Private","title":"Diagnostics","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [FourierFlows]\nPublic  = false\nPages   = [\"diagnostics.jl\"]","category":"page"},{"location":"library/internals/#Base.getindex-Tuple{Diagnostic, Union{AbstractString, Symbol}}","page":"Private","title":"Base.getindex","text":"e.g. plot(energydiag[:t], energydiag[:data]).\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#FourierFlows.extend!-Tuple{Any, Any}","page":"Private","title":"FourierFlows.extend!","text":"extend!(diag, n)\n\nExtend the data, time, and steps vectors of the diagnostic diag by n.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#FourierFlows.extend!-Union{Tuple{Diagnostic{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"Private","title":"FourierFlows.extend!","text":"extend!(diag::Diagnostic{T,N})\n\nDouble the extend of the data, time, and steps vectors of the diagnostic diag.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#Output","page":"Private","title":"Output","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [FourierFlows]\nPublic  = false\nPages   = [\"output.jl\"]","category":"page"},{"location":"library/internals/#FourierFlows.savefield-Tuple{Any, Any, Any}","page":"Private","title":"FourierFlows.savefield","text":"savefield(file, location, data)\n\nSaves a particular field's data to file.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#FourierFlows.savefields-Tuple{JLD2.JLDFile{JLD2.MmapIO}, TwoDGrid}","page":"Private","title":"FourierFlows.savefields","text":"savefields(file, grid)\n\nSaves some parameters of problem's grid to file.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#FourierFlows.uniquepath-Tuple{Any}","page":"Private","title":"FourierFlows.uniquepath","text":"uniquepath(path)\n\nReturn path with a number appended if isfile(path) == true. The number is incremented until path does not exist.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#Timesteppers","page":"Private","title":"Timesteppers","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [FourierFlows]\nPublic = false\nPages   = [\"timesteppers.jl\"]","category":"page"},{"location":"library/internals/#FourierFlows.getetdcoeffs-Tuple{Any, Any}","page":"Private","title":"FourierFlows.getetdcoeffs","text":"getetdcoeffs(dt, L; ncirc=32, rcirc=1)\n\nCalculate the coefficients associated with the (diagonal) linear coefficient L for an ETDRK4 timestepper with timestep dt.\n\nThe calculation is done by integrating over a unit circle in the complex space. For more info refer to [2].\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#Diffusion-Testbed-Module","page":"Private","title":"Diffusion Testbed Module","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [FourierFlows.Diffusion]\nPublic  = false\nPages   = [\"diffusion.jl\"]","category":"page"},{"location":"library/internals/#FourierFlows.Diffusion.Params","page":"Private","title":"FourierFlows.Diffusion.Params","text":"struct Params{T} <: AbstractParams\n\nThe parameters for diffusion problem:\n\nŒ∫::Any: diffusivity coefficient\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#FourierFlows.Diffusion.Vars","page":"Private","title":"FourierFlows.Diffusion.Vars","text":"struct Vars{Aphys, Atrans} <: AbstractVars\n\nThe variables for diffusion problem:\n\nc: tracer concentration\ncx: tracer concentration derivative\nch: Fourier transform of tracer concentration\ncxh: Fourier transform of tracer concentration derivative\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#FourierFlows.Diffusion.Vars-Union{Tuple{AbstractGrid{T}}, Tuple{T}} where T","page":"Private","title":"FourierFlows.Diffusion.Vars","text":"Vars(grid)\n\nReturn the variables vars for a constant diffusivity problem on grid.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#FourierFlows.Diffusion.Equation-Union{Tuple{D}, Tuple{T}, Tuple{AbstractGrid{T}, FourierFlows.Diffusion.Params{D}}} where {T, D<:Number}","page":"Private","title":"FourierFlows.Diffusion.Equation","text":"Equation(grid, params)\n\nReturn the equation for a constant diffusivity problem on grid with diffusivity found inside params.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#FourierFlows.Diffusion.calcN!-Union{Tuple{D}, Tuple{Any, Any, Any, Any, Any, FourierFlows.Diffusion.Params{D}, Any}} where D<:Number","page":"Private","title":"FourierFlows.Diffusion.calcN!","text":"calcN!(N, sol, t, clock, vars, params, grid)\n\nCalculate the nonlinear term for the 1D diffusion equation.\n\n\n\n\n\n","category":"method"},{"location":"grids/#Grids","page":"Grids","title":"Grids","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"1D, 2D, and 3D grids are supported. We demonstrate here the construction of a  one-dimensional grid and how one can use it to perform Fourier transforms and  compute spatial derivatives.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"A one-dimensional grid with n_x = 64 grid points and length L_x = 2 pi is  constructed by","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"DocTestSetup = quote\n    using FourierFlows\nend","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"using FourierFlows\n\nnx, Lx = 64, 2œÄ\n\ngrid = OneDGrid(; nx, Lx, x0 = -Lx/3)\n\n# output\n\nOneDimensionalGrid\n  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Device: CPU\n  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FloatType: Float64\n  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ size Lx: 6.283185307179586\n  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ resolution nx: 64\n  ‚îú‚îÄ‚îÄ grid spacing dx: 0.09817477042468103\n  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ domain: x ‚àà [-2.0943951023931953, 4.090615434361711]\n  ‚îî‚îÄ aliased fraction: 0.3333333333333333","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"The grid domain is, by default, constructed symmetrically around x = 0, but this can be  altered using the x0 keyword argument of the OneDGrid constructor. The grid spacing  is L_x  n_x. Note that the last point of the domain is a grid-spacing before L_x  2.  This is because periodicity implies that the values of any field at the end-points of the  domain are equal and, therefore, grid-point values at both these end-points are redundant.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"We can define an array u that contains the values of a function u(x) on this  grid. If, for example, u is","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"u(x) = sin(2x) + frac12 cos(5x) ","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"then","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"using FourierFlows\nusing LinearAlgebra: mul!, ldiv!\nusing CairoMakie\nCairoMakie.activate!(type = \"svg\")\nset_theme!(Theme(linewidth = 3, fontsize = 20))\nnx, Lx = 64, 2œÄ\ngrid = OneDGrid(; nx, Lx, x0 = -Lx/3)","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"u = @. sin(2 * grid.x) + 1/2 * cos(5 * grid.x)\n\nnothing # hide","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"Note that we chose a function u that is periodic on our domain. We can visualize u by","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"using CairoMakie\n\nlines(grid.x, u, label=\"u\", axis = (xlabel=\"x\",))\naxislegend()\n\ncurrent_figure() # hide","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"Any periodic function u(x) can be expanded in Fourier series:","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"u(x) = sum_k hatu(k)  e^i k x ","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"where hatu(k) is Fourier transform of u(x) and k the discrete set of  wavenumbers that fit within our finite domain. We can compute hatu via a  Fast Fourier Transform (FFT). Since u array is real-valued then we should  use the real-FFT algorithm. The real-valued FFT transform only saves the Fourier  coefficients for k ge 0; the coefficients for negative wavenumbers can be  obtained via hatu(-k) = hatu(k)^*.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"The wavenumbers used in FFT are contained in grid.k and they are ordered as:","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"frac2piL_x  0 1 dots n_x2-1 -n_x2 -n_x2+1 dots -1  ","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"while the wavenumbers for real FFT are in grid.kr:","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"frac2piL_x  0 1 dots n_x2-1  ","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"The grid also includes the FFT plans for both real-valued and complex valued transforms:","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"grid.fftplan","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"grid.rfftplan","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"We use the convention that variables names with h at the end stand for variable-hat, i.e.,  hatu  is the Fourier transform of u and is stored in array uh. Since u is of  size n_x, the real-Fourier transform should be of size n_kr = n_x2 + 1.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"uh = Complex.(zeros(grid.nkr))\n\nnothing # hide","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"The FFT transform is done as an in-place matrix multiplication using mul!.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"using LinearAlgebra: mul!\n\nmul!(uh, grid.rfftplan, u)\n\nnothing # hide","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"The FFT algorithm does not output exactly the Fourier coefficients hatu(k) but rather, due to different normalization, FFT outputs something proportional to hatu(k).  To obtain hatu we need to divide the FFT output by the length of the original array and by e^i k x_0, where x_0 is the first point of our domain array.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"uhat = @. uh / (nx * exp(im * grid.kr * grid.x[1])) # due to normalization of FFT\n\nfig = Figure()\nax = Axis(fig[1, 1];\n          xlabel = \"k\",\n          limits = ((-0.5, 10.5), (-0.55, 0.55)),\n          xticks = 0:10,\n          yticks = -0.5:0.25:0.5)\n\nscatterlines!(ax, grid.kr, real.(uhat);\n              markersize = 16, label = \"real(uÃÇ)\")\n\nscatterlines!(ax, grid.kr, imag.(uhat);\n              markersize = 22, marker = :diamond, label = \"imag(uÃÇ)\")\n\naxislegend()\n\ncurrent_figure() # hide","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"Note that with the normalization we get what we expect since","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"u(x) = sin(2x) + frac12 cos(5x) = -fraci2 (e^2ix - e^-2ix) + frac14 (e^5ix + e^-5ix) ","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"We can compute the derivative of u(x) via Fourier transforms. To do that we use the FFTW plans that are constructed with the grid. First we allocate some empty arrays where the values of the derivative will be stored, both in physical and in Fourier space:","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"‚àÇ‚Çìu  = similar(u)\n‚àÇ‚Çìuh = similar(uh)\n\nnothing # hide","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"The grid contains the wavenumbers (both for real-value functions grid.kr and  for complex-valued functions grid.k). We populate the array ‚àÇ‚Çìuh with mathrmi k hatu:","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"@. ‚àÇ‚Çìuh = im * grid.kr * uh\n\nnothing # hide","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"Then the derivative in physical space, ‚àÇ‚Çìu, is obtained through an inverse Fourier  transform. For this again we use the FFTW plans but now via ldiv!:","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"using LinearAlgebra: ldiv!\n\nldiv!(‚àÇ‚Çìu, grid.rfftplan, ‚àÇ‚Çìuh)","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"We can plot ‚àÇ‚Çìu and compare it with the analytic derivative. ","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"fig = Figure()\nax = Axis(fig[1, 1], xlabel = \"x\")\n\nlines!(ax, grid.x, u;\n       label = \"u\")\nlines!(ax, grid.x, ‚àÇ‚Çìu;\n       label = \"‚àÇu/‚àÇx\")\nlines!(ax, grid.x, @. 2 * cos(2 * grid.x) - 5/2 * sin(5 * grid.x);\n       linewidth=1.5, linestyle=:dash, label = \"analytical ‚àÇu/‚àÇx\")\n\naxislegend()\n\ncurrent_figure() # hide","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"EditURL = \"../../../examples/OneDShallowWaterGeostrophicAdjustment.jl\"","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/#Linear-rotating-shallow-water-dynamics","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"","category":"section"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"This example can be run online via (Image: ). Also, it can be viewed as a Jupyter notebook via (Image: ).","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"This example solves the linear 1D rotating shallow water equations for the u(x t), v(x t) and the surface surface elevation eta(x t), for a fluid with constant rest-depth H. That is, the total fluid's depth is H + eta(x t) with eta ll H.","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"The linearized equations for the evolution of u, v, eta are:","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"beginaligned\npartial_t u - f v  = - g partial_x eta - mathrmD u \npartial_t v + f u  = - mathrmD v \npartial_t eta + H partial_x u  = - mathrmD eta\nendaligned","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"Above, g is the gravitational acceleration, f is the  Coriolis parameter, and mathrmD indicates a hyperviscous linear operator of the form (-1)^n_ŒΩ ŒΩ nabla^2 n_ŒΩ, with ŒΩ the viscosity coefficient and n_ŒΩ the order of the operator.","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"Rotation introduces the deformation length scale, L_d = sqrtg H  f. Disturbances with length scales much smaller than L_d don't \"feel\" the rotation and propagate as inertia-gravity waves. Disturbances with length scales comparable or larger than L_d should be approximately in geostrophic balance, i.e., the Coriolis acceleration f widehatbmz times bmu should be in approximate balance with the pressure gradient -g bmnabla eta.","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"using FourierFlows, CairoMakie, Printf, Random, JLD2\nusing LinearAlgebra: mul!, ldiv!","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/#Coding-up-the-equations","page":"Linear rotating shallow water dynamics","title":"Coding up the equations","text":"","category":"section"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/#A-demonstration-of-FourierFlows.jl-framework","page":"Linear rotating shallow water dynamics","title":"A demonstration of FourierFlows.jl framework","text":"","category":"section"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"What follows is a step-by-step tutorial demonstrating how you can create your own solver for an equation of your liking.","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"The basic building blocks for a FourierFlows.Problem are:","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"Grid struct containining the physical and wavenumber grid for the problem,\nParams struct containining all the parameters of the problem,\nVars struct containining arrays with the variables used in the problem,\nEquation struct containining the coefficients of the linear operator L and the function that computes the nonlinear terms, usually named calcN!().","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"The Grid structure is provided by FourierFlows.jl. We simply have to call one of either OneDGrid(), TwoDGrid(), or ThreeDGrid() constructors, depending on the dimensionality of the problem. All other structs mentioned above are problem-specific and need to be constructed for every set of equations we want to solve.","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"First let's construct the Params struct that contains all parameters of the problem.","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"struct Params{T} <: AbstractParams\n   ŒΩ :: T         # Hyperviscosity coefficient\n  nŒΩ :: Int       # Order of the hyperviscous operator\n   g :: T         # Gravitational acceleration\n   H :: T         # Fluid depth\n   f :: T         # Coriolis parameter\nend\nnothing #hide","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"Now the Vars struct that contains all variables used in this problem. For this problem Vars includes the representations of the flow fields in physical space u, v and Œ∑ and their Fourier transforms uh, vh, and Œ∑h.","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"struct Vars{Aphys, Atrans} <: AbstractVars\n   u :: Aphys\n   v :: Aphys\n   Œ∑ :: Aphys\n  uh :: Atrans\n  vh :: Atrans\n  Œ∑h :: Atrans\nend\nnothing #hide","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"A constructor populates empty arrays based on the dimension of the grid and then creates Vars struct.","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"\"\"\"\n    Vars(grid)\n\nConstruct the `Vars` for 1D linear shallow water dynamics based on the dimensions of the `grid` arrays.\n\"\"\"\nfunction Vars(grid)\n  Dev = typeof(grid.device)\n  T = eltype(grid)\n\n  @devzeros Dev T grid.nx u v Œ∑\n  @devzeros Dev Complex{T} grid.nkr uh vh Œ∑h\n\n  return Vars(u, v, Œ∑, uh, vh, Œ∑h)\nend\nnothing #hide","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"In Fourier space, the 1D linear shallow water dynamics read:","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"beginaligned\nfracpartial hatupartial t  = underbrace f hatv - i k g hateta _N_u  underbrace- nu k^2 _L_u hatu  \nfracpartial hatvpartial t  = underbrace - f hatu _N_v  underbrace- nu k^2 _L_v hatv  \nfracpartial hatetapartial t  = underbrace - i k H hatu _N_eta  underbrace- nu k^2 _L_eta hateta \nendaligned","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"Although, e.g., terms involving the Coriolis accelaration are, in principle, linear we include them in the nonlinear term N because they render the linear operator L non-diagonal.","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"With these in mind, we construct function calcN! that computes the nonlinear terms.","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"\"\"\"\n    calcN!(N, sol, t, clock, vars, params, grid)\n\nCompute the nonlinear terms for 1D linear shallow water dynamics.\n\"\"\"\nfunction calcN!(N, sol, t, clock, vars, params, grid)\n  @. vars.uh = sol[:, 1]\n  @. vars.vh = sol[:, 2]\n  @. vars.Œ∑h = sol[:, 3]\n\n  @. N[:, 1] =   params.f * vars.vh - im * grid.kr * params.g * vars.Œ∑h    #  + f v - g ‚àÇŒ∑/‚àÇx\n  @. N[:, 2] = - params.f * vars.uh                                        #  - f u\n  @. N[:, 3] = - im * grid.kr * params.H * vars.uh                         #  - H ‚àÇu/‚àÇx\n\n  dealias!(N, grid)\n\n  return nothing\nend\nnothing #hide","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"Next we construct the Equation struct:","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"\"\"\"\n    Equation(params, grid)\n\nConstruct the equation: the linear part, in this case the hyperviscous dissipation,\nand the nonlinear part, which is computed by `calcN!` function.\n\"\"\"\nfunction Equation(params, grid)\n  T = eltype(grid)\n  dev = grid.device\n\n  L = zeros(dev, T, (grid.nkr, 3))\n  D = @. - params.ŒΩ * grid.kr^(2*params.nŒΩ)\n\n  L[:, 1] .= D # for u equation\n  L[:, 2] .= D # for v equation\n  L[:, 3] .= D # for Œ∑ equation\n\n  return FourierFlows.Equation(L, calcN!, grid)\nend\nnothing #hide","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"We now have all necessary building blocks to construct a FourierFlows.Problem. It would be useful, however, to define some more \"helper functions\". For example, a function that updates all variables given the solution sol which comprises hatu, hatv and hateta:","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"\"\"\"\n    updatevars!(prob)\n\nUpdate the variables in `prob.vars` using the solution in `prob.sol`.\n\"\"\"\nfunction updatevars!(prob)\n  vars, grid, sol = prob.vars, prob.grid, prob.sol\n\n  @. vars.uh = sol[:, 1]\n  @. vars.vh = sol[:, 2]\n  @. vars.Œ∑h = sol[:, 3]\n\n  ldiv!(vars.u, grid.rfftplan, deepcopy(sol[:, 1])) # use deepcopy() because irfft destroys its input\n  ldiv!(vars.v, grid.rfftplan, deepcopy(sol[:, 2])) # use deepcopy() because irfft destroys its input\n  ldiv!(vars.Œ∑, grid.rfftplan, deepcopy(sol[:, 3])) # use deepcopy() because irfft destroys its input\n\n  return nothing\nend\nnothing #hide","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"Another useful function is one that prescribes an initial condition to the state variable sol.","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"\"\"\"\n    set_uvŒ∑!(prob, u0, v0, Œ∑0)\n\nSet the state variable `prob.sol` as the Fourier transforms of `u0`, `v0`, and `Œ∑0`\nand update all variables in `prob.vars`.\n\"\"\"\nfunction set_uvŒ∑!(prob, u0, v0, Œ∑0)\n  vars, grid, sol = prob.vars, prob.grid, prob.sol\n\n  A = typeof(vars.u) # determine the type of vars.u\n\n  # below, e.g., A(u0) converts u0 to the same type as vars expects\n  # (useful when u0 is a CPU array but grid.device is GPU)\n  mul!(vars.uh, grid.rfftplan, A(u0))\n  mul!(vars.vh, grid.rfftplan, A(v0))\n  mul!(vars.Œ∑h, grid.rfftplan, A(Œ∑0))\n\n  @. sol[:, 1] = vars.uh\n  @. sol[:, 2] = vars.vh\n  @. sol[:, 3] = vars.Œ∑h\n\n  updatevars!(prob)\n\n  return nothing\nend\nnothing #hide","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/#Let's-prescibe-parameter-values-and-solve-the-PDE","page":"Linear rotating shallow water dynamics","title":"Let's prescibe parameter values and solve the PDE","text":"","category":"section"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"We are now ready to write up a program that sets up parameter values, constructs the problem prob, # time steps the solutions prob.sol and plots it.","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/#Choosing-a-device:-CPU-or-GPU","page":"Linear rotating shallow water dynamics","title":"Choosing a device: CPU or GPU","text":"","category":"section"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"dev = CPU()    # Device (CPU/GPU)\nnothing # hide","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/#Numerical-parameters-and-time-stepping-parameters","page":"Linear rotating shallow water dynamics","title":"Numerical parameters and time-stepping parameters","text":"","category":"section"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"     nx = 512            # grid resolution\nstepper = \"FilteredRK4\"  # timestepper\n     dt = 20.0           # timestep (s)\n nsteps = 320            # total number of time-steps\nnothing # hide","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/#Physical-parameters","page":"Linear rotating shallow water dynamics","title":"Physical parameters","text":"","category":"section"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"Lx = 500e3      # Domain length (m)\ng  = 9.8        # Gravitational acceleration (m s‚Åª¬≤)\nH  = 200.0      # Fluid depth (m)\nf  = 1e-2       # Coriolis parameter (s‚Åª¬π)\nŒΩ  = 100.0      # Viscosity (m¬≤ s‚Åª¬π)\nnŒΩ = 1          # Viscosity order (nŒΩ = 1 means Laplacian ‚àá¬≤)\nnothing # hide","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/#Construct-the-structs-and-you-are-ready-to-go!","page":"Linear rotating shallow water dynamics","title":"Construct the structs and you are ready to go!","text":"","category":"section"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"Create a grid and also params, vars, and the equation structs. Then give them all as input to the FourierFlows.Problem() constructor to get a problem struct, prob, that contains all of the above.","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"    grid = OneDGrid(dev; nx, Lx)\n  params = Params(ŒΩ, nŒΩ, g, H, f)\n    vars = Vars(grid)\nequation = Equation(params, grid)\n\n    prob = FourierFlows.Problem(equation, stepper, dt, grid, vars, params)\nnothing #hide","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/#Setting-initial-conditions","page":"Linear rotating shallow water dynamics","title":"Setting initial conditions","text":"","category":"section"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"For initial condition we take the fluid at rest (u = v = 0). The free surface elevation is perturbed from its rest position (eta=0); the disturbance we impose a Gaussian bump with half-width greater than the deformation radius and on top of that we superimpose some random noise with scales smaller than the deformation radius. We mask the small-scale perturbations so that it only applies in the central part of the domain by applying","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"The system develops geostrophically-balanced jets around the Gaussian bump, while the smaller-scale noise propagates away as inertia-gravity waves.","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"First let's construct the Gaussian bump.","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"gaussian_width = 6e3\ngaussian_amplitude = 3.0\ngaussian_bump = @. gaussian_amplitude * exp( - grid.x^2 / (2*gaussian_width^2) )\n\nfig = Figure(resolution = (600, 260))\nax =  Axis(fig[1, 1];\n           xlabel = \"x [km]\",\n           ylabel = \"Œ∑ [m]\",\n           title = \"A gaussian bump with half-width ‚âà \" * string(gaussian_width/1e3) * \" km\",\n           limits = ((-Lx/2e3, Lx/2e3), nothing))\n\nlines!(ax, grid.x/1e3, gaussian_bump;    # divide with 1e3 to convert m -> km\n       color = (:black, 0.7),\n       linewidth = 2)\n\nsave(\"gaussian_bump.svg\", fig); nothing # hide","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"(Image: )","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"Next the noisy perturbation. The mask is simply a product of hyperbolic tangent functions.","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"mask = @. 1/4 * (1 + tanh( -(grid.x - 100e3) / 10e3)) * (1 + tanh( (grid.x + 100e3) / 10e3))\n\nnoise_amplitude = 0.1 # the amplitude of the noise for Œ∑(x, t=0) (m)\nŒ∑_noise = noise_amplitude * Random.randn(size(grid.x))\n@. Œ∑_noise *= mask    # mask the noise\n\nfig = Figure(resolution = (600, 520))\n\nkwargs = (xlabel = \"x [km]\", limits = ((-Lx/2e3, Lx/2e3), nothing))\n\nax1 =  Axis(fig[1, 1]; ylabel = \"Œ∑ [m]\", title = \"small-scale noise\", kwargs...)\n\nax2 =  Axis(fig[2, 1]; ylabel = \"mask\", kwargs...)\n\nlines!(ax1, grid.x/1e3, Œ∑_noise;      # divide with 1e3 to convert m -> km\n       color = (:black, 0.7),\n       linewidth = 3)\n\nlines!(ax2, grid.x/1e3, mask;         # divide with 1e3 to convert m -> km\n       color = (:gray, 0.7),\n       linewidth = 2)\n\nsave(\"noise-mask.svg\", fig); nothing # hide","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"(Image: )","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"Sum the Gaussian bump and the noise and then call set_uvŒ∑!() to set the initial condition to the problem prob.","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"Œ∑0 = @. gaussian_bump + Œ∑_noise\nu0 = zeros(grid.nx)\nv0 = zeros(grid.nx)\n\nset_uvŒ∑!(prob, u0, v0, Œ∑0)\n\nfig = Figure(resolution = (600, 260))\n\nax =  Axis(fig[1, 1];\n           xlabel = \"x [km]\",\n           ylabel = \"Œ∑ [m]\",\n           title = \"initial surface elevation, Œ∑(x, t=0)\",\n           limits = ((-Lx/2e3, Lx/2e3), nothing))\n\nlines!(ax, grid.x/1e3, Œ∑0;    # divide with 1e3 to convert m -> km\n       color = (:black, 0.7),\n       linewidth = 2)\n\nsave(\"initial_eta.svg\", fig); nothing # hide","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"(Image: )","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/#Saving-output","page":"Linear rotating shallow water dynamics","title":"Saving output","text":"","category":"section"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"filepath = \".\"\nfilename = joinpath(filepath, \"linear_swe.jld2\")\n\nget_sol(prob) = prob.sol\n\nout = Output(prob, filename, (:sol, get_sol))","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"We call saveproblem to we write the problem's configuration parameters to the .jld2 file.","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"saveproblem(out)","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/#Time-stepping-the-Problem-forward","page":"Linear rotating shallow water dynamics","title":"Time-stepping the Problem forward","text":"","category":"section"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"for j = 0:nsteps\n  updatevars!(prob)\n  stepforward!(prob)\n  saveoutput(out)\nend","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/#Visualizing-the-simulation","page":"Linear rotating shallow water dynamics","title":"Visualizing the simulation","text":"","category":"section"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"First we load the saved output files.","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"using JLD2\n\nfile = jldopen(out.path)\niterations = parse.(Int, keys(file[\"snapshots/t\"]))\n\nnx = file[\"grid/nx\"]\n x = file[\"grid/x\"]","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"Then we animate the output. We use Makie's Observable to animate the data. To dive into how Observables work we refer to Makie.jl's Documentation.","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":" n = Observable(1)\n\nu = @lift irfft(file[string(\"snapshots/sol/\", iterations[$n])][:, 1], nx)\nv = @lift irfft(file[string(\"snapshots/sol/\", iterations[$n])][:, 2], nx)\nŒ∑ = @lift irfft(file[string(\"snapshots/sol/\", iterations[$n])][:, 3], nx)\n\ntoptitle = @lift \"t = \" * @sprintf(\"%.1f\", file[string(\"snapshots/t/\", iterations[$n])]/60) * \" min\"\n\nfig = Figure(resolution = (600, 800))\n\nkwargs_Œ∑ = (xlabel = \"x [km]\", limits = ((-Lx/2e3, Lx/2e3), nothing))\nkwargs_uv = (xlabel = \"x [km]\", limits = ((-Lx/2e3, Lx/2e3), (-0.3, 0.3)))\n\nax_Œ∑ =  Axis(fig[2, 1]; ylabel = \"Œ∑ [m]\", title = toptitle, kwargs_Œ∑...)\n\nax_u =  Axis(fig[3, 1]; ylabel = \"u [m s‚Åª¬π]\", kwargs_uv...)\n\nax_v =  Axis(fig[4, 1]; ylabel = \"v [m s‚Åª¬π]\", kwargs_uv...)\n\nLd = @sprintf \"%.2f\" sqrt(g * H) / f /1e3     # divide with 1e3 to convert m -> km\ntitle = \"Deformation radius ‚àö(gh) / f = \"*string(Ld)*\" km\"\n\nfig[1, 1] = Label(fig, title, fontsize=24, tellwidth=false)\n\nlines!(ax_Œ∑, grid.x/1e3, Œ∑; # divide with 1e3 to convert m -> km\n       color = (:blue, 0.7))\n\nlines!(ax_u, grid.x/1e3, u; # divide with 1e3 to convert m -> km\n       color = (:red, 0.7))\n\nlines!(ax_v, grid.x/1e3, v; # divide with 1e3 to convert m -> km\n       color = (:green, 0.7))\n\nframes = 1:length(iterations)\n\nrecord(fig, \"onedshallowwater.mp4\", frames, framerate=18) do i\n    n[] = i\nend\nnothing #hide","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"(Image: )","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/#Geostrophic-balance","page":"Linear rotating shallow water dynamics","title":"Geostrophic balance","text":"","category":"section"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"It is instructive to compare the solution for bmu with its geostrophically balanced approximation, f widehatbmz times bmu_rm geostrophic = - g bmnabla eta, i.e.,","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"beginaligned\nv_rm geostrophic  =   fracgf fracpartial etapartial x   \nu_rm geostrophic  = - fracgf fracpartial etapartial y = 0  \nendaligned","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"u_geostrophic = zeros(grid.nx)  # -g/f ‚àÇŒ∑/‚àÇy = 0\nv_geostrophic = params.g / params.f * irfft(im * grid.kr .* vars.Œ∑h, grid.nx)  #g/f ‚àÇŒ∑/‚àÇx\n\nnothing # hide","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"The geostrophic solution should capture well the the behavior of the flow in the center of the domain, after small-scale disturbances propagate away. Let's plot and see!","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"fig = Figure(resolution = (600, 600))\n\nkwargs = (xlabel = \"x [km]\", limits = ((-Lx/2e3, Lx/2e3), (-0.3, 0.3)))\n\nax_u =  Axis(fig[2, 1]; ylabel = \"u [m s‚Åª¬π]\", kwargs...)\n\nax_v =  Axis(fig[3, 1]; ylabel = \"v [m s‚Åª¬π]\", kwargs...)\n\nfig[1, 1] = Label(fig, \"Geostrophic balance\", fontsize=24, tellwidth=false)\n\nlines!(ax_u, grid.x/1e3, vars.u; # divide with 1e3 to convert m -> km\n       label = \"u\",\n       linewidth = 3,\n       color = (:red, 0.7))\n\nlines!(ax_u, grid.x/1e3, u_geostrophic; # divide with 1e3 to convert m -> km\n       label = \"- g/f ‚àÇŒ∑/‚àÇy\",\n       linewidth = 3,\n       color = (:purple, 0.7))\n\naxislegend(ax_u)\n\nlines!(ax_v, grid.x/1e3, vars.v; # divide with 1e3 to convert m -> km\n       label = \"v\",\n       linewidth = 3,\n       color = (:green, 0.7))\n\nlines!(ax_v, grid.x/1e3, v_geostrophic; # divide with 1e3 to convert m -> km\n       label = \"g/f ‚àÇŒ∑/‚àÇx\",\n       linewidth = 3,\n       color = (:purple, 0.7))\n\naxislegend(ax_v)\n\nsave(\"geostrophic_balance.svg\", fig); nothing # hide","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"(Image: )","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"This page was generated using Literate.jl.","category":"page"},{"location":"library/function_index/#main-index","page":"Function index","title":"Index","text":"","category":"section"},{"location":"library/function_index/","page":"Function index","title":"Function index","text":"Pages = [\"public.md\", \"internals.md\", \"function_index.md\"]","category":"page"},{"location":"problem/#problem_docs","page":"Problem","title":"Problem","text":"","category":"section"},{"location":"problem/","page":"Problem","title":"Problem","text":"using FourierFlows\nusing LinearAlgebra: mul!, ldiv!\nusing CairoMakie\nCairoMakie.activate!(type = \"svg\")\nset_theme!(Theme(linewidth = 3, fontsize = 20))","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"Everything needed to solve a PDE in FourierFlows.jl is gathered in a composite type named Problem. Problem contains various other composite types (see Problem for details).","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"Here, we demonstrate how we can construct a Problem to solve the simple 1D equation:","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"partial_t u(x t) = - alpha  u(x t) ","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"on domain x in -1 1.","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"First, we construct our grid","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"using FourierFlows\n\nnx, Lx = 32, 2.0\n\ngrid = OneDGrid(; nx, Lx)","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"Our problem has a parameter alpha. Thus, we create a Params as:","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"struct Params <: AbstractParams\n  Œ± :: Float64\nend","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"and then we use the Params's constructor to populate our params with the parameter value,  e.g., alpha = 01:","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"Œ± = 0.1\n\nparams = Params(Œ±)","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"The particular equation is so simple that it makes no difference performance-wise whether  we time-step it in physical or in wavenumber space. For PDEs with nonlinear terms,  time-stepping in wavenumber space is much more efficient. Thus, for demonstration purposes,  we will time-step the equation in wavenumber space, i.e.,","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"partial_t hatu(k t) = - alpha  hatu(k t) ","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"The variables involved are u and its Fourier transform hatu. Thus, we  construct the vars as:","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"struct Vars <: AbstractVars\n    u :: Array{Float64, 1}\n   uh :: Array{Complex{Float64}, 1}\nend","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"and, like before, we use the Vars's constructor to populate the vars with  zero arrays,","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"vars = Vars(zeros(Float64, (grid.nx,)), zeros(Complex{Float64}, (grid.nkr,)))","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"Note that the Fourier transform of a real-valued array u is complex-valued. Also because we use the real Fourier transform, the array uh is smaller.","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"In this example our state variable is simply uh, i.e., sol = uh.","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"Next we need to construct the equation. The equation contains the linear coefficients  for the linear part of the PDE, stored in an array L, and the function calcN!() that calculates the nonlinear terms from the state variable sol. In our case, our equation is linear and, therefore,","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"L = - params.Œ± * ones(grid.nkr)\n\nnothing # hide","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"and","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"function calcN!(N, sol, t, clock, vars, params, grid)\n  @. N = 0\n\n  return nothing\nend\n\nnothing # hide","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"Note that calcN!() needs to have the above argument structure. With L and calcN! in hand we can construct our problem's equation:","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"equation = FourierFlows.Equation(L, calcN!, grid)","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"Last, we have to pick a time-stepper and a time-step dt and gather everything a FourierFlows's Problem.","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"Time-steppers are prescribed via a string. Here we choose \"ForwardEuler\" time-stepping scheme with a time step of 0.02.","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"stepper, dt = \"ForwardEuler\", 0.02\n\nprob = FourierFlows.Problem(equation, stepper, dt, grid, vars, params)","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"For more information and a list of implemented time-stepping schemes see the the following Time-stepping section.","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"By default, the Problem constructor takes sol a complex valued array filled with zeros with same size as L.","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"The prob.clock contains the time-step dt and the current step and time t of the simulation:","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"prob.clock","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"Let's initiate our problem with, e.g., u(x 0) = cos(pi x), integrate up  to t = 4 and compare our numerical solution with the analytic solution  u(x t) = e^-alpha t cos(pi x).","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"u0 = @. cos(œÄ * grid.x)\n\nusing LinearAlgebra: mul!\n\nmul!(prob.sol, grid.rfftplan, u0)\n\nnothing # hide","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"Since our time-step is chosen dt = 0.02, we need to step forward prob for 200  time-steps to reach t = 4.","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"stepforward!(prob, 200)","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"Now let's transform our state vector sol back in physical space","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"using LinearAlgebra: ldiv!\n\nldiv!(prob.vars.u, grid.rfftplan, prob.sol)\n\nnothing # hide","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"and finally, let's plot our solution and compare with the analytic solution:","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"using CairoMakie, Printf\n\nfig = Figure()\nax = Axis(fig[1, 1], xlabel = \"x\", title = @sprintf(\"u(x, t=%1.2f)\", prob.clock.t))\n\nx = range(-Lx/2, Lx/2, length=200)\nlines!(ax, x, @. cos(œÄ * x) * exp(-prob.params.Œ± * 4); label = \"analytical\")\nlines!(ax, x, @. cos(œÄ * x); linestyle = :dash, color = :gray, label = \"initial condition\")\n\nscatter!(ax, grid.x, prob.vars.u; markersize = 14, color = :salmon, label = \"numerical\")\n\naxislegend()\n\ncurrent_figure() # hide","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"A good practice is to encompass all functions and type definitions related with a PDE under  a single module, e.g.,","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"module MyPDE\n\n  ...\n\nend # end module","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"For a more elaborate example we urge you to have a look at the Diffusion  module located at src/diffusion.jl and also the modules included in the child package GeophysicalFlows.jl.","category":"page"},{"location":"gpu/#GPU","page":"GPU","title":"GPU","text":"","category":"section"},{"location":"gpu/","page":"GPU","title":"GPU","text":"FourierFlows allows you to easily construct and run problems on GPUs.","category":"page"},{"location":"gpu/","page":"GPU","title":"GPU","text":"Upon calling","category":"page"},{"location":"gpu/","page":"GPU","title":"GPU","text":"using FourierFlows","category":"page"},{"location":"gpu/","page":"GPU","title":"GPU","text":"FourierFlows.jl will check whether any CUDA enabled device is present. If such a device is  found then FourierFlows.jl makes sure that CUDA related packages are loaded and also it will  overload all methods to work with GPU() device as their argument (instead of the standard  CPU() device).","category":"page"},{"location":"gpu/","page":"GPU","title":"GPU","text":"It's easy to construct a grid that lives on the GPU. Calling:","category":"page"},{"location":"gpu/","page":"GPU","title":"GPU","text":"nx, Lx = 16, 2.0\ngrid = OneDGrid(GPU(); nx, Lx)\n\nOneDimensionalGrid\n  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Device: GPU\n  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FloatType: Float64\n  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ size Lx: 2.0\n  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ resolution nx: 16\n  ‚îú‚îÄ‚îÄ grid spacing dx: 0.125\n  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ domain: x ‚àà [-1.0, 0.875]\n  ‚îî‚îÄ aliased fraction: 0.3333333333333333","category":"page"},{"location":"gpu/","page":"GPU","title":"GPU","text":"returns a grid whose arrays are CuArrays. (Calling OneDGrid(; nx, Lx) defaults to using CPU(), i.e., OneDGrid(CPU(); nx, Lx).)","category":"page"},{"location":"gpu/","page":"GPU","title":"GPU","text":"When we construct the Params, Vars, and Equation for our problem we need to make sure that we create arrays on the appropriate device, i.e., Arrays for CPU or CuArrays for the GPU. Function device_array is useful in constructing appropriately chosen arrays.","category":"page"},{"location":"gpu/","page":"GPU","title":"GPU","text":"device_array","category":"page"},{"location":"gpu/#FourierFlows.device_array","page":"GPU","title":"FourierFlows.device_array","text":"device_array(device::Device)\ndevice_array(device::Device, T, dim)\n\nReturn the proper array type according to the device, i.e., Array for CPU and CuArray for GPU.\n\n\n\n\n\ndevice_array(grid::AbstractGrid)\n\nReturn the proper array type according to the grid's device, i.e., Array for CPU and CuArray for GPU.\n\n\n\n\n\n","category":"function"},{"location":"gpu/","page":"GPU","title":"GPU","text":"The FourierFlows.Problem constructor infers the device from the grid that is provided.","category":"page"},{"location":"gpu/","page":"GPU","title":"GPU","text":"problem = Problem(equation, stepper, dt, grid, vars, params)","category":"page"},{"location":"gpu/","page":"GPU","title":"GPU","text":"The FourierFlows.Diffusion module is written in a way such that switching from CPU to GPU  is only a matter of calling FourierFlows.Diffusion.Problem() with dev=GPU(). All physics  modules in GeophysicalFlows.jl can  also seamlessly run on a GPU with dev=GPU() argument.","category":"page"},{"location":"gpu/#Selecting-GPU-device","page":"GPU","title":"Selecting GPU device","text":"","category":"section"},{"location":"gpu/","page":"GPU","title":"GPU","text":"FourierFlows.jl can only utilize a single GPU. If your machine has more than one GPU available,  then functionality within CUDA.jl package enables the user to choose the GPU device that  FourierFlows.jl should use. The user is referred to the CUDA.jl Documentation; in particular, CUDA.devices and CUDA.CuDevice.","category":"page"},{"location":"#FourierFlows.jl-Documentation","page":"Home","title":"FourierFlows.jl Documentation","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"FourierFlows provides a framework to write solvers for partial differential equations on periodic domains with Fourier-based pseudospectral methods that run seamlessly on CPUs and GPUs. We support 1-, 2-, and 3-dimensional domains.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The next few sections step through the basics of building and a module to solve a partial differential equation.","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A demonstration for how to code up and solve the linear shallow water equations is found in the Examples section of the documentation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more examples of FourierFlows.jl in action, see the child packages GeophysicalFlows.jl or PassiveTracerFlows.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"info: Unicode\nOften unicode symbols appear in modules for variables or parameters. For example, Œ∫ appears as the diffusivity in the Diffusion module. Unicode symbols can be entered  in the Julia REPL by typing, e.g., \\kappa followed by tab key. Read more about Unicode  symbols in the Julia Documentation.","category":"page"},{"location":"#Developers","page":"Home","title":"Developers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"FourierFlows.jl started during the on Atmospheric and Oceanic Fluid Dynamics Meeting 2017 by Greg Wagner and Navid Constantinou. Since then various people have contributed.","category":"page"},{"location":"#Cite","page":"Home","title":"Cite","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The software is citable via zenodo.","category":"page"},{"location":"timestepping/#timestepping","page":"Time stepping","title":"Time-stepping","text":"","category":"section"},{"location":"timestepping/","page":"Time stepping","title":"Time stepping","text":"FourierFlows.jl includes several time-stepping algorithms.","category":"page"},{"location":"timestepping/","page":"Time stepping","title":"Time stepping","text":"Most of the time-stepping algorithms are fully explicit schemes: ForwardEulerTimeStepper, AB3TimeStepper, RK4TimeStepper, and LSRK54TimeStepper. Also we have implemented an ETDRK4TimeStepper scheme with the improvements described by [2].","category":"page"},{"location":"timestepping/","page":"Time stepping","title":"Time stepping","text":"The Problem constructor expects the chosen time stepper as as string that includes the corresponding name of the time stepper without the ending TimeStepper. For example, \"RK4\" for the Runge-Kutta 4th-order time stepper.","category":"page"},{"location":"timestepping/#High-wavenumber-filtering","page":"Time stepping","title":"High-wavenumber filtering","text":"","category":"section"},{"location":"timestepping/","page":"Time stepping","title":"Time stepping","text":"Most of the time steppers also come with their Filtered equivalents: FilteredForwardEulerTimeStepper, FilteredAB3TimeStepper, FilteredRK4TimeStepper, FilteredLSRK54TimeStepper, and FilteredETDRK4TimeStepper.","category":"page"},{"location":"timestepping/","page":"Time stepping","title":"Time stepping","text":"The filtered time steppers apply a high-wavenumber filter to the solution at the end of each step. The motivation behind filtering is to preclude enstrophy from accumulating at high wavenumbers and creating noise at grid-scale level.","category":"page"},{"location":"timestepping/","page":"Time stepping","title":"Time stepping","text":"The high-wavenumber filter used in the filtered time steppers is:","category":"page"},{"location":"timestepping/","page":"Time stepping","title":"Time stepping","text":"mathrmfilter(boldsymbolk) = \n  begincases\n    1  quad boldsymbolk  k_textrmcutoff  \n    exp left - alpha (boldsymbolk - k_textrmcutoff)^p right  quad boldsymbolk  k_textrmcutoff  \n  endcases","category":"page"},{"location":"timestepping/","page":"Time stepping","title":"Time stepping","text":"For fluid equations with quadratic non-linearities it makes sense to choose a cut-off wavenumber at 2/3 of the highest wavenumber that is resolved in our domain, k_textrmcutoff = tfrac23 k_textrmmax (see discussion in Aliasing section).","category":"page"},{"location":"timestepping/","page":"Time stepping","title":"Time stepping","text":"Given the order p, we choose coefficient alpha so that the filter value that corresponds to the highest allowed wavenumber in our domain is a small number delta, usually taken to be close to machine precision. That is:","category":"page"},{"location":"timestepping/","page":"Time stepping","title":"Time stepping","text":"alpha = frac- logdelta(k_textrmmax - k_textrmcutoff)^p  ","category":"page"},{"location":"timestepping/","page":"Time stepping","title":"Time stepping","text":"The above-mentioned filter form originates from the book by [3]. In geophysical turbulence applications it was used by [4] and later by [5].","category":"page"},{"location":"timestepping/","page":"Time stepping","title":"Time stepping","text":"warning: Not too steep, not too shallow\nCare should be taken if one decides to fiddle with the filter parameters. Changing the order p affects how steeply the filter falls off. Lower order values imply that the filter might fall off too quickly and may lead to Gibbs artifacts; higher order value implies that the filter might fall off too slow and won't suffice to remove enstrophy accumulating at the grid scale.","category":"page"},{"location":"timestepping/","page":"Time stepping","title":"Time stepping","text":"The filter using the default parameters provided by the filtered time steppers (see FourierFlows.makefilter) is depicted below. The same plot also compares how the filter changes when we vary the order parameter p while keeping everything else the same.","category":"page"},{"location":"timestepping/","page":"Time stepping","title":"Time stepping","text":"using CairoMakie\nCairoMakie.activate!(type = \"svg\")\nset_theme!(Theme(linewidth = 3, fontsize = 20))","category":"page"},{"location":"timestepping/","page":"Time stepping","title":"Time stepping","text":"using CairoMakie\nusing FourierFlows: makefilter\n\nK = 0:0.001:1 # non-dimensional wavenumber k * dx / œÄ\n\nfig = Figure()\nax = Axis(fig[1, 1], xlabel = \"|ùê§| dx / œÄ\", ylabel = \"filter\", aspect=2.5, xticks=0:0.2:1)\n\nvlines!(ax, 2/3, color = (:gray, 0.4), linewidth = 6, label = \"cutoff wavenumber |ùê§| dx / œÄ = 2/3 (default)\")\n\nlines!(ax, K, makefilter(K), linewidth = 4, label = \"order 4 (default)\")\nlines!(ax, K, makefilter(K, order = 1), linestyle = :dash, label = \"order 1\")\nlines!(ax, K, makefilter(K, order = 10), linestyle = :dot, label = \"order 10\")\n\naxislegend(position = :lb)\n\ncurrent_figure() # hide","category":"page"},{"location":"library/public/#Public-Documentation","page":"Public","title":"Public Documentation","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Documentation for FourierFlows.jl's public interface.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"See the Internals section of the manual for internal package docs covering all submodules.","category":"page"},{"location":"library/public/#FourierFlows","page":"Public","title":"FourierFlows","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [FourierFlows]\nPrivate = false\nPages   = [\"FourierFlows.jl\"]","category":"page"},{"location":"library/public/#FourierFlows.FourierFlows","page":"Public","title":"FourierFlows.FourierFlows","text":"Main module for FourierFlows.jl ‚Äì an ecosystem for solving partial differential equations  on periodic domains using Fourier-based pseudospectral methods.\"\n\nExports\n\nAB3TimeStepper\nAbstractGrid\nAbstractParams\nAbstractTimeStepper\nAbstractVars\nCPU\nDevice\nDiagnostic\nETDRK4TimeStepper\nFilteredAB3TimeStepper\nFilteredETDRK4TimeStepper\nFilteredForwardEulerTimeStepper\nFilteredLSRK54TimeStepper\nFilteredRK4TimeStepper\nForwardEulerTimeStepper\nGPU\nLSRK54TimeStepper\nOneDGrid\nOutput\nRK4TimeStepper\nThreeDGrid\nTimeStepper\nTwoDGrid\n@createarrays\ncxtype\ndealias!\ndevice_array\n@devzeros\nfft\nfltype\ngridpoints\ngroupsize\nifft\nincrement!\ninnereltype\nirfft\nresize!\nrfft\nsavediagnostic\nsaveoutput\nsaveproblem\nstep_until!\nstepforward!\nsupersize\n@superzeros\nsuperzeros\nupdate!\n@zeros\n\n\n\n\n\n","category":"module"},{"location":"library/public/#FourierFlows.AbstractGrid","page":"Public","title":"FourierFlows.AbstractGrid","text":"Abstract supertype for grids.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.AbstractParams","page":"Public","title":"FourierFlows.AbstractParams","text":"Abstract supertype for parameters.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.AbstractTimeStepper","page":"Public","title":"FourierFlows.AbstractTimeStepper","text":"Abstract supertype for timesteppers.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.AbstractVars","page":"Public","title":"FourierFlows.AbstractVars","text":"Abstract supertype for variables.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.CPU","page":"Public","title":"FourierFlows.CPU","text":"CPU device.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.Device","page":"Public","title":"FourierFlows.Device","text":"Abstract supertype for supported devices.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.GPU","page":"Public","title":"FourierFlows.GPU","text":"GPU device.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#Problem","page":"Public","title":"Problem","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [FourierFlows]\nPrivate = false\nPages   = [\"problem.jl\"]","category":"page"},{"location":"library/public/#Domain","page":"Public","title":"Domain","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [FourierFlows]\nPrivate = false\nPages   = [\"domains.jl\"]","category":"page"},{"location":"library/public/#FourierFlows.OneDGrid","page":"Public","title":"FourierFlows.OneDGrid","text":"OneDGrid(dev::Device = CPU();\n         nx, Lx,\n         x0 = -Lx/2, nthreads = Sys.CPU_THREADS, effort = FFTW.MEASURE, \n         T = Float64, aliased_fraction = 1/3)\n\nConstruct a OneDGrid on device; by default on CPU(). Grid size is Lx, resolution is nx,  and leftmost position is x0. FFT plans are generated for nthreads CPUs using FFTW flag effort. The float type is T. The aliased_fraction keyword determines the highest wavenubers that are being zero-ed out by dealias! function; 1/3 is the nominal value for quadratic nonlinearities. \n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.OneDGrid-2","page":"Public","title":"FourierFlows.OneDGrid","text":"struct OneDGrid{T<:AbstractFloat, A, Tx, Tfft, Trfft, Talias} <: AbstractGrid{T, A, Talias, D}\n\nA one-dimensional grid.\n\ndevice::Any: device which the grid lives on\nnx::Int64: number of points in x\nnk::Int64: number of wavenumbers in x\nnkr::Int64: number of positive wavenumbers in x (real Fourier transforms)\ndx::AbstractFloat: grid spacing in x\nLx::AbstractFloat: domain extent in x\nx::Any: range with x-grid-points\nk::Any: array with x-wavenumbers\nkr::Any: array with positive x-wavenumbers (real Fourier transforms)\ninvksq::Any: array with inverse squared k-wavenumbers, 1  k¬≤\ninvkrsq::Any: array with inverse squared k·µ£-wavenumbers, 1  k·µ£¬≤\nfftplan::Any: the FFT plan for complex-valued fields\nrfftplan::Any: the FFT plan for real-valued fields\naliased_fraction::AbstractFloat: the fraction of wavenumbers that are aliased (e.g., 1/3 for quadradic nonlinearities)\nkalias::Any: range of the indices of aliased x-wavenumbers\nkralias::Any: range of the indices of aliased positive x-wavenumbers (real Fourier transforms)\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.ThreeDGrid","page":"Public","title":"FourierFlows.ThreeDGrid","text":"ThreeDGrid(dev::Device=CPU(); nx, Lx, ny=nx, Ly=Lx, nz=nx, Lz=Lx,\n           x0=-Lx/2, y0=-Ly/2, z0=-Lz/2,\n           nthreads=Sys.CPU_THREADS, effort=FFTW.MEASURE, T=Float64,\n           aliased_fraction=1/3)\n\nConstruct a ThreeDGrid on device; by default on CPU(). Grid size is Lx, Ly, Lz, resolution is nx, ny, nz and leftmost positions are x0, y0, z0. FFT plans are generated for nthreads CPUs using FFTW flag effort. The float type is T. The aliased_fraction keyword determines the highest wavenubers that are being zero-ed out by dealias! function; 1/3 is the nominal value for quadratic nonlinearities. \n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.ThreeDGrid-2","page":"Public","title":"FourierFlows.ThreeDGrid","text":"struct ThreeDGrid{T<:AbstractFloat, Tk, Tx, Tfft, Trfft, Talias} <: AbstractGrid{T, Tk, Talias}\n\nA three-dimensional grid.\n\ndevice::Any: device which the grid lives on\nnx::Int64: number of points in x\nny::Int64: number of points in y\nnz::Int64: number of points in z\nnk::Int64: number of wavenumbers in x\nnl::Int64: number of wavenumbers in y\nnm::Int64: number of wavenumbers in z\nnkr::Int64: number of positive wavenumers in x (real Fourier transforms)\ndx::AbstractFloat: grid spacing in x\ndy::AbstractFloat: grid spacing in y\ndz::AbstractFloat: grid spacing in z\nLx::AbstractFloat: domain extent in x\nLy::AbstractFloat: domain extent in y\nLz::AbstractFloat: domain extent in z\nx::Any: range with x-grid-points\ny::Any: range with y-grid-points\nz::Any: range with z-grid-points\nk::Any: array with x-wavenumbers\nl::Any: array with y-wavenumbers\nm::Any: array with z-wavenumbers\nkr::Any: array with positive x-wavenumbers (real Fourier transforms)\nKsq::Any: array with squared total wavenumbers, k¬≤ + l¬≤ + m¬≤\ninvKsq::Any: array with inverse squared total wavenumbers, 1  (k¬≤ + l¬≤ + m¬≤)\nKrsq::Any: array with squared total wavenumbers for real Fourier transforms, k·µ£¬≤ + l¬≤ + m¬≤\ninvKrsq::Any: array with inverse squared total wavenumbers for real Fourier transforms, 1  (k·µ£¬≤ + l¬≤ + m¬≤)\nfftplan::Any: the FFT plan for complex-valued fields\nrfftplan::Any: the FFT plan for real-valued fields\naliased_fraction::AbstractFloat: the fraction of wavenumbers that are aliased (e.g., 1/3 for quadradic nonlinearities)\nkalias::Any: range of the indices of aliased x-wavenumbers\nkralias::Any: range of the indices of aliased positive x-wavenumbers (real Fourier transforms)\nlalias::Any: range of the indices of aliased y-wavenumbers\nmalias::Any: range of the indices of aliased m-wavenumbers\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.TwoDGrid","page":"Public","title":"FourierFlows.TwoDGrid","text":"TwoDGrid(dev::Device=CPU(); nx, Lx, ny=nx, Ly=Lx,\n         x0=-Lx/2, y0=-Ly/2, nthreads=Sys.CPU_THREADS, effort=FFTW.MEASURE,\n         T=Float64, aliased_fraction=1/3)\n\nConstruct a TwoDGrid on device; by default on CPU(). Grid size is Lx, Ly, resolution is nx, ny, and leftmost positions are x0, y0. FFT plans are generated for nthreads CPUs using FFTW flag effort. The float type is T. The aliased_fraction keyword determines the highest wavenubers that are being zero-ed out by dealias! function; 1/3 is the nominal value for quadratic nonlinearities. \n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.TwoDGrid-2","page":"Public","title":"FourierFlows.TwoDGrid","text":"struct TwoDGrid{T<:AbstractFloat, A, Tx, Tfft, Trfft, Talias, D} <: AbstractGrid{T, Tk, Talias, D}\n\nA two-dimensional grid.\n\ndevice::Any: device which the grid lives on\nnx::Int64: number of points in x\nny::Int64: number of points in y\nnk::Int64: number of wavenumbers in x\nnl::Int64: number of wavenumbers in y\nnkr::Int64: number of positive wavenumers in x (real Fourier transforms)\ndx::AbstractFloat: grid spacing in x\ndy::AbstractFloat: grid spacing in y\nLx::AbstractFloat: domain extent in x\nLy::AbstractFloat: domain extent in y\nx::Any: range with x-grid-points\ny::Any: range with y-grid-points\nk::Any: array with x-wavenumbers\nl::Any: array with y-wavenumbers\nkr::Any: array with positive x-wavenumbers (real Fourier transforms)\nKsq::Any: array with squared total wavenumbers, k¬≤ + l¬≤\ninvKsq::Any: array with inverse squared total wavenumbers, 1  (k¬≤ + l¬≤)\nKrsq::Any: array with squared total wavenumbers for real Fourier transforms, k·µ£¬≤ + l¬≤\ninvKrsq::Any: array with inverse squared total wavenumbers for real Fourier transforms, 1  (k·µ£¬≤ + l¬≤)\nfftplan::Any: the FFT plan for complex-valued fields\nrfftplan::Any: the FFT plan for real-valued fields\naliased_fraction::AbstractFloat: the fraction of wavenumbers that are aliased (e.g., 1/3 for quadradic nonlinearities)\nkalias::Any: range of the indices of aliased x-wavenumbers\nkralias::Any: range of the indices of aliased positive x-wavenumbers (real Fourier transforms)\nlalias::Any: range of the indices of aliased y-wavenumbers\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.dealias!-Tuple{Any, Any}","page":"Public","title":"FourierFlows.dealias!","text":"dealias!(fh, grid)\n\nDealias array fh on the grid based on the grids's aliased_fraction.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.gridpoints-Union{Tuple{OneDGrid{T, A}}, Tuple{A}, Tuple{T}} where {T, A}","page":"Public","title":"FourierFlows.gridpoints","text":"gridpoints(grid::OneDDGrid)\ngridpoints(grid::TwoDGrid)\ngridpoints(grid::ThreeDGrid)\n\nReturn the collocation points of the grid in 1D (X),  2D (X, Y) or 3D arrays (X, Y, Z).\n\n\n\n\n\n","category":"method"},{"location":"library/public/#Utilities","page":"Public","title":"Utilities","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [FourierFlows]\nPrivate = false\nPages   = [\"utils.jl\"]","category":"page"},{"location":"library/public/#FourierFlows.cxtype-Union{Tuple{Type{T}}, Tuple{T}} where T<:Number","page":"Public","title":"FourierFlows.cxtype","text":"cxtype(T)\n\nReturns T when T is Complex, or Complex{T} when T is Real.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.device_array-Tuple{AbstractGrid}","page":"Public","title":"FourierFlows.device_array","text":"device_array(grid::AbstractGrid)\n\nReturn the proper array type according to the grid's device, i.e., Array for CPU and CuArray for GPU.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.device_array-Tuple{CPU}","page":"Public","title":"FourierFlows.device_array","text":"device_array(device::Device)\ndevice_array(device::Device, T, dim)\n\nReturn the proper array type according to the device, i.e., Array for CPU and CuArray for GPU.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.fltype-Union{Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Public","title":"FourierFlows.fltype","text":"fltype(T)\n\nReturns T when T<:AbstractFloat or Tf when T<:Complex{Tf}.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.innereltype-Tuple{Any}","page":"Public","title":"FourierFlows.innereltype","text":"innereltype(x)\n\nRecursively determine the 'innermost' type in by the collection x (which may be, for example, a collection of a collection).\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.superzeros-Tuple{Any, AbstractArray}","page":"Public","title":"FourierFlows.superzeros","text":"superzeros(T, A)\n\nReturns an array like A, but full of zeros. If innereltype(A) can be promoted to T, then the innermost elements of the array will have type T.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.@devzeros-Tuple{Any, Any, Any, Vararg{Any}}","page":"Public","title":"FourierFlows.@devzeros","text":"@devzeros dev T dims a b c...\n\nCreate arrays of all zeros with element type T, size dims, and global names a, b, c (for example) on device dev.\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#FourierFlows.@superzeros-Tuple{Any, Any, Vararg{Any}}","page":"Public","title":"FourierFlows.@superzeros","text":"@superzeros T a b c d...\n@superzeros T dims b c d...\n\nGenerate arrays b, c, d... with the super-dimensions of a and innereltype T.\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#FourierFlows.@zeros-Tuple{Any, Any, Vararg{Any}}","page":"Public","title":"FourierFlows.@zeros","text":"@zeros T dims a b c...\n\nCreate arrays of all zeros with element type T, size dims, and global names a, b, c (for example). An arbitrary number of arrays may be created.\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#Diagnostics","page":"Public","title":"Diagnostics","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [FourierFlows]\nPrivate = false\nPages   = [\"diagnostics.jl\"]","category":"page"},{"location":"library/public/#FourierFlows.Diagnostic","page":"Public","title":"FourierFlows.Diagnostic","text":"mutable struct Diagnostic{T, N} <: AbstractDiagnostic\n\nA diagnostic that includes N elements of type T.\n\ncalc::Function: function that returns the diagnostic via calc(prob)\nprob::FourierFlows.Problem: the relevant problem for this diagnostic\ndata::Vector: vector where the diagnostic time-series is saved\nt::Vector{Float64}: vector with the times for which the diagnostic was saved\nsteps::Vector{Int64}: vector with the problem's step for which the diagnostic was saved\nfreq::Int64: integer denoting how often (every how many problem.steps) to save the diagnostic\ni::Int64: integer denoting how many times the diagnostic.data was updated\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.Diagnostic-Tuple{Any, Any}","page":"Public","title":"FourierFlows.Diagnostic","text":"Diagnostic(calc, prob; freq=1, nsteps=100, ndata=ceil(Int, (nsteps+1)/freq))\n\nConstruct a diagnostic that stores the result of calc(prob) with frequency freq.\n\nKeywords\n\nfreq: Diagnostic is saved every freq steps.\nnsteps: The total number of steps in problem.\nndata: The number of diagnostics to be saved.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.increment!-Tuple{Any}","page":"Public","title":"FourierFlows.increment!","text":"increment!(diag)\n\nIncrement the Diagnostic diag, or an array of Diagnostics diags.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.update!-Tuple{Any, Any}","page":"Public","title":"FourierFlows.update!","text":"update!(diag)\n\nUpdate diag.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#Output","page":"Public","title":"Output","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [FourierFlows]\nPrivate = false\nPages   = [\"output.jl\"]","category":"page"},{"location":"library/public/#FourierFlows.Output","page":"Public","title":"FourierFlows.Output","text":"struct Output\n\nThe composite type for output.\n\nprob::FourierFlows.Problem: the relevant problem for the output\npath::String: the path for the output file\nfields::Dict{Symbol, Function}: the fields to be saved; the relevant problem for this diagnostic\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.Output-Tuple{Any, Any, Dict{Symbol, Function}}","page":"Public","title":"FourierFlows.Output","text":"Output(prob, filename, fieldtuples...)\n\nDefine output for prob with fields and functions that calculate the output in the list of tuples fieldtuples = (fldname, func)....\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.savediagnostic-Tuple{Any, Any, Any}","page":"Public","title":"FourierFlows.savediagnostic","text":"savediagnostic(diagnostic, diagname, filename)\n\nSave diagnostic to filename under name diagname. Only the computed diagnostic is saved, that is, everything up to diagnostic's iteration diagnostic.i.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.saveoutput-Tuple{Any}","page":"Public","title":"FourierFlows.saveoutput","text":"saveoutput(out)\n\nSave the fields in out.fields to out.path.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.saveproblem-Tuple{Any, Any}","page":"Public","title":"FourierFlows.saveproblem","text":"saveproblem(prob, filename)\n\nSave certain aspects of a problem prob to filename.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#Timesteppers","page":"Public","title":"Timesteppers","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [FourierFlows]\nPrivate = false\nPages   = [\"timesteppers.jl\"]","category":"page"},{"location":"library/public/#FourierFlows.AB3TimeStepper","page":"Public","title":"FourierFlows.AB3TimeStepper","text":"AB3TimeStepper(equation::Equation, dev::Device=CPU())\n\nConstruct a 3rd order Adams-Bashforth timestepper for equation on device dev.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.AB3TimeStepper-2","page":"Public","title":"FourierFlows.AB3TimeStepper","text":"struct AB3TimeStepper{T} <: AbstractTimeStepper{T}\n\nA 3rd-order Adams-Bashforth timestepper for time-stepping ‚àÇu/‚àÇt = RHS(u, t) via:\n\nu‚Åø‚Å∫¬π = u‚Åø + dt/12 * (23 * RHS(u‚Åø, t‚Åø) - 16 * RHS(u‚Åø‚Åª¬π, t‚Åø‚Åª¬π) + 5 * RHS(u‚Åø‚Åª¬≤, t‚Åø‚Åª¬≤))\n\nAdams-Bashforth is a multistep method, i.e., it not only requires information from the n-th time-step (u‚Åø) but also from the previous two timesteps (u‚Åø‚Åª¬π and u‚Åø‚Åª¬≤). For the first two timesteps, it falls back to a forward Euler timestepping scheme:\n\nu‚Åø‚Å∫¬π = u‚Åø + dt * RHS(u‚Åø, t‚Åø)\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.ETDRK4TimeStepper","page":"Public","title":"FourierFlows.ETDRK4TimeStepper","text":"ETDRK4TimeStepper(equation::Equation, dt, dev::Device=CPU())\n\nConstruct a 4th-order exponential-time-differencing Runge-Kutta timestepper with timestep dt for equation on device dev.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.ETDRK4TimeStepper-2","page":"Public","title":"FourierFlows.ETDRK4TimeStepper","text":"struct ETDRK4TimeStepper{T,TL} <: AbstractTimeStepper{T}\n\nA 4th-order exponential-time-differencing Runge-Kutta timestepper for time-stepping ‚àÇu/‚àÇt = L * u + N(u). The scheme treats the linear term L exactly while for the nonlinear terms N(u) it uses a 4th-order Runge-Kutta scheme (RK4TimeStepper). That is,\n\nu‚Åø‚Å∫¬π = exp(L * dt) * u‚Åø + RK4(N(u‚Åø))\n\nFor more info refer to [2].\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.FilteredAB3TimeStepper","page":"Public","title":"FourierFlows.FilteredAB3TimeStepper","text":"FilteredAB3TimeStepper(equation::Equation, dev::Device=CPU(); filterkwargs...)\n\nConstruct a 3rd order Adams-Bashforth timestepper with spectral filtering for equation on device dev.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.FilteredAB3TimeStepper-2","page":"Public","title":"FourierFlows.FilteredAB3TimeStepper","text":"struct FilteredAB3TimeStepper{T} <: AbstractTimeStepper{T}\n\nA 3rd order Adams-Bashforth timestepper with spectral filtering. See AB3TimeStepper.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.FilteredETDRK4TimeStepper","page":"Public","title":"FourierFlows.FilteredETDRK4TimeStepper","text":"FilteredETDRK4TimeStepper(equation, dt; filterkwargs...)\n\nConstruct a 4th-order exponential-time-differencing Runge-Kutta timestepper with timestep dt and  spectral filtering for equation on device dev.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.FilteredETDRK4TimeStepper-2","page":"Public","title":"FourierFlows.FilteredETDRK4TimeStepper","text":"FilteredETDRK4TimeStepper{T,TL,Tf} <: AbstractTimeStepper{T}\n\nA 4th-order exponential-time-differencing Runge-Kutta timestepper with spectral filtering. See ETDRK4TimeStepper.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.FilteredForwardEulerTimeStepper","page":"Public","title":"FourierFlows.FilteredForwardEulerTimeStepper","text":"FilteredForwardEulerTimeStepper(equation, dev; filterkwargs...)\n\nConstruct a Forward Euler timestepper with spectral filtering for equation on device dev.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.FilteredForwardEulerTimeStepper-2","page":"Public","title":"FourierFlows.FilteredForwardEulerTimeStepper","text":"struct FilteredForwardEulerTimeStepper{T,Tf} <: AbstractTimeStepper{T}\n\nA forward Euler timestepper with spectral filtering. See ForwardEulerTimeStepper.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.FilteredLSRK54TimeStepper","page":"Public","title":"FourierFlows.FilteredLSRK54TimeStepper","text":"FilteredRK4TimeStepper(equation::Equation, dev::Device=CPU(); filterkwargs...)\n\nConstruct a 4th-order 5-stages 2-storage Runge-Kutta timestepper with spectral filtering for equation on device dev.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.FilteredLSRK54TimeStepper-2","page":"Public","title":"FourierFlows.FilteredLSRK54TimeStepper","text":"struct FilteredLSRK54TimeStepper{T,V,Tf} <: AbstractTimeStepper{T}\n\nA 4th-order 5-stages low-storage Runge-Kutta timestepper with spectral filtering. See LSRK54TimeStepper.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.FilteredRK4TimeStepper","page":"Public","title":"FourierFlows.FilteredRK4TimeStepper","text":"FilteredRK4TimeStepper(equation::Equation, dev::Device=CPU(); filterkwargs...)\n\nConstruct a 4th-order Runge-Kutta timestepper with spectral filtering for equation on device dev.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.FilteredRK4TimeStepper-2","page":"Public","title":"FourierFlows.FilteredRK4TimeStepper","text":"struct FilteredRK4TimeStepper{T,Tf} <: AbstractTimeStepper{T}\n\nA 4th-order Runge-Kutta timestepper with spectral filtering. See RK4TimeStepper.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.ForwardEulerTimeStepper","page":"Public","title":"FourierFlows.ForwardEulerTimeStepper","text":"ForwardEulerTimeStepper(equation::Equation, dev::Device=CPU())\n\nConstruct a forward Euler timestepper for equation on device dev.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.ForwardEulerTimeStepper-2","page":"Public","title":"FourierFlows.ForwardEulerTimeStepper","text":"struct ForwardEulerTimeStepper{T} <: AbstractTimeStepper{T}\n\nA forward Euler timestepper for time-stepping ‚àÇu/‚àÇt = RHS(u, t) via:\n\nu‚Åø‚Å∫¬π = u‚Åø + dt * RHS(u‚Åø, t‚Åø)\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.LSRK54TimeStepper","page":"Public","title":"FourierFlows.LSRK54TimeStepper","text":"LSRK54TimeStepper(equation::Equation, dev::Device=CPU())\n\nConstruct a 4th-order 5-stages low-storage Runge-Kutta timestepper for equation on device dev.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.LSRK54TimeStepper-2","page":"Public","title":"FourierFlows.LSRK54TimeStepper","text":"struct LSRK54TimeStepper{T} <: AbstractTimeStepper{T}\n\nA 4th-order 5-stages 2-storage Runge-Kutta timestepper for time-stepping ‚àÇu/‚àÇt = RHS(u, t) via:\n\nS¬≤ = 0\n\nfor i = 1:5\n  S¬≤ = A·µ¢ * S¬≤ + dt * RHS(u‚Åø, t‚ÇÄ + C·µ¢ * dt)\n  u‚Åø += B·µ¢ * S¬≤\nend\n\nu‚Åø‚Å∫¬π = u‚Åø\n\nwhere A·µ¢, B·µ¢, and C·µ¢ are the A, B, and C coefficients from the LSRK table at the i-th stage. For details, refer to [6].\n\ninfo: Usage\nThe LSRK54TimeStepper is slower than the RK4TimeStepper but has less memory footprint; half compared to RK4TimeStepper.If your simulation is bound by performance then use RK4TimeStepper; if your simulation is bound by memory then consider using LSRK54TimeStepper.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.RK4TimeStepper","page":"Public","title":"FourierFlows.RK4TimeStepper","text":"RK4TimeStepper(equation::Equation, dev::Device=CPU())\n\nConstruct a 4th-order Runge-Kutta timestepper for equation on device dev.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.RK4TimeStepper-2","page":"Public","title":"FourierFlows.RK4TimeStepper","text":"struct RK4TimeStepper{T} <: AbstractTimeStepper{T}\n\nA 4th-order Runge-Kutta timestepper for time-stepping ‚àÇu/‚àÇt = RHS(u, t) via:\n\nu‚Åø‚Å∫¬π = u‚Åø + dt/6 * (k‚ÇÅ + 2 * k‚ÇÇ + 2 * k‚ÇÉ + k‚ÇÑ)\n\nwhere\n\nk‚ÇÅ = RHS(u‚Åø, t‚Åø)\nk‚ÇÇ = RHS(u‚Åø + k‚ÇÅ * dt/2, t‚Åø + dt/2)\nk‚ÇÉ = RHS(u‚Åø + k‚ÇÇ * dt/2, t‚Åø + dt/2)\nk‚ÇÑ = RHS(u‚Åø + k‚ÇÉ * dt, t‚Åø + dt)\n\ninfo: Usage\nIf your simulation is limited by memory then consider switching to LSRK54TimeStepper. The LSRK54TimeStepper timestepper has about half the memory footprint compared to the RK4TimeStepper with a about 25%-30% performance trade off.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.TimeStepper","page":"Public","title":"FourierFlows.TimeStepper","text":"TimeStepper(stepper, equation, dt=nothing, dev=CPU(); kw...)\n\nInstantiate the Timestepper for equation with timestep dt and on the device. The keyword arguments, kw, are passed to the timestepper constructor.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#FourierFlows.step_until!-Tuple{Any, Any}","page":"Public","title":"FourierFlows.step_until!","text":"step_until!(prob, stop_time)\n\nStep forward prob until stop_time.\n\nwarn: Fully-explicit timestepping schemes are required\nWe cannot use step_until! with ETDRK4TimeStepper nor FilteredETDRK4TimeStepper.\n\nSee also: stepforward!\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.stepforward!-Tuple{FourierFlows.Problem, Any, Int64}","page":"Public","title":"FourierFlows.stepforward!","text":"stepforward!(prob::Problem, diags, nsteps::Int)\n\nStep forward prob for nsteps, incrementing diags along the way. diags may be a  single Diagnostic or a Vector of Diagnostics.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.stepforward!-Tuple{FourierFlows.Problem, Int64}","page":"Public","title":"FourierFlows.stepforward!","text":"stepforward!(prob::Problem, nsteps::Int)\n\nStep forward prob for nsteps.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.stepforward!-Tuple{FourierFlows.Problem}","page":"Public","title":"FourierFlows.stepforward!","text":"stepforward!(prob::Problem)\n\nStep forward prob one time step.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#Diffusion-Testbed-Module","page":"Public","title":"Diffusion Testbed Module","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [FourierFlows.Diffusion]\nPrivate = false\nPages   = [\"diffusion.jl\"]","category":"page"},{"location":"library/public/#FourierFlows.Diffusion","page":"Public","title":"FourierFlows.Diffusion","text":"A test-bed module that solves the 1D diffusion equation.\n\nExports\n\nProblem\nset_c!\nupdatevars!\n\n\n\n\n\n","category":"module"},{"location":"library/public/#FourierFlows.Diffusion.Problem","page":"Public","title":"FourierFlows.Diffusion.Problem","text":"Problem(dev::Device = CPU();\n                 nx = 128,\n                 Lx = 2œÄ,\n                  Œ∫ = 0,\n                 dt = 0.01,\n            stepper = \"RK4\",           \n   aliased_fraction = 0,\n                  T = Float64)\n\nConstruct a constant diffusivity problem.\n\nKeyword arguments\n\ndev: (required) CPU() or GPU(); computer architecture used to time-step problem.\nnx: Number of grid points in x-domain.\nLx: Extent of the x-domain.\nŒ∫: Diffusivity coefficient.\ndt: Time-step.\nstepper: The extent of the y-domain.\naliased_fraction: the fraction of high-wavenubers that are zero-ed out by dealias!().\nT: Float64 or Float32; floating point type used for problem data.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#FourierFlows.Diffusion.set_c!-Tuple{Any, Any}","page":"Public","title":"FourierFlows.Diffusion.set_c!","text":"set_c!(prob, c)\n\nSet the solution sol as the transform of c and update vars.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.Diffusion.updatevars!-Tuple{Any, Any, Any}","page":"Public","title":"FourierFlows.Diffusion.updatevars!","text":"updatevars!(vars, grid, sol)\n\nUpdate the variables in vars on the grid with the solution in sol.\n\n\n\n\n\n","category":"method"}]
}
