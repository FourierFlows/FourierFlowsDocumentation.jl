var documenterSearchIndex = {"docs":
[{"location":"contributing/#Contributors-Guide","page":"Contributor's guide","title":"Contributors Guide","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"This is a short guide for potential FourierFlows.jl contributors.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Please feel free to ask us questions and chat, either by raising an issue or starting a discussion.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"We follow the ColPrac guide for collaborative practices.  New contributors should make sure to read that guide.","category":"page"},{"location":"contributing/#What-can-I-do?","page":"Contributor's guide","title":"What can I do?","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Tackle an existing issue.\nImprove documentation, docstrings, or comments if you found something is hard to use.\nImplement a new feature (e.g., a new diagnostic into a module).","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"If you're interested in working on something, let us know by commenting on an existing issue  or by opening a new issue. This is to make sure no one else is working on the same issue and  so we can help and guide you in case there is anything you need to know beforehand.","category":"page"},{"location":"contributing/#Ground-Rules","page":"Contributor's guide","title":"Ground Rules","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Each pull request should consist of a logical collection of changes. You can include multiple bug fixes in a single pull request, but they should be related. For unrelated changes, please submit multiple pull requests.\nDo not commit changes to files that are irrelevant to your feature or bugfix (e.g., .gitignore).\nBe willing to accept criticism and work on improving your code; we don't want to break other users' code, so care must be taken not to introduce bugs. We discuss pull requests and keep working on them until we believe we've done a good job.\nBe aware that the pull request review process is not immediate, and is generally proportional to the size of the pull request.","category":"page"},{"location":"contributing/#Reporting-a-bug","page":"Contributor's guide","title":"Reporting a bug","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"The easiest way to get involved is to report issues you encounter when using FourierFlows.jl  or by requesting something you think is missing.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Head over to the issues page.\nSearch to see if your issue already exists or has even been solved previously.\nIf you indeed have a new issue or request, click the \"New Issue\" button.\nPlease be as specific as possible. Include the version of the code you were using, as well as what operating system you are running. The output of Julia's versioninfo() and ] status is helpful to include. If possible, include complete, minimal example code that reproduces the problem.","category":"page"},{"location":"contributing/#Setting-up-your-development-environment","page":"Contributor's guide","title":"Setting up your development environment","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Install Julia on your system.\nInstall git on your system if it is not already there (install XCode command line tools on a Mac or git bash on Windows).\nLogin to your GitHub account and make a fork of the FourierFlows.jl repository by clicking the \"Fork\" button.\nClone your fork of the FourierFlows.jl repository (in terminal on Mac/Linux or git shell/ GUI on Windows) in the location you'd like to keep it.\ngit clone https://github.com/your-user-name/FourierFlows.jl.git\nNavigate to that folder in the terminal or in Anaconda Prompt if you're on Windows.\nConnect your repository to the upstream (main project).\ngit remote add FourierFlows https://github.com/FourierFlows/FourierFlows.jl.git\nCreate the development environment by opening Julia via julia --project then typing in ] instantiate. This will install all the dependencies in the Project.toml file.\nYou can test to make sure FourierFlows.jl works by typing in ] test. This will run all the tests (this can take a while). In an ideal world you should run the tests on a machine with a GPU capability but if that's not a possibility that is available to you then don't  worry – simply comment in a PR that you didn't test on GPU.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Your development environment is now ready!","category":"page"},{"location":"contributing/#Pull-Requests","page":"Contributor's guide","title":"Pull Requests","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Changes and contributions should be made via GitHub pull requests against the master branch.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"When you're done making changes, commit the changes you made. Chris Beams has written  a guide on how to write good commit messages.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"When you think your changes are ready to be merged into the main repository, push to your fork and submit a pull request.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Working on your first Pull Request? You can learn how from this free video series How to Contribute to an Open Source Project on GitHub, Aaron Meurer's tutorial on the git workflow,  or the guide “How to Contribute to Open Source\".","category":"page"},{"location":"contributing/#Documentation","page":"Contributor's guide","title":"Documentation","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"All PRs that introduce new features or new modules should be accompanied with appropriate  docstrings and documentation. Writing documentation strings is really important to make sure  others use your functionality properly. Didn't write new functions? That's fine, but be sure  that the documentation for the code you touched is still in great shape. It is not uncommon  to find some strange wording or clarification that you can take care of while you are here.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"We encourage using unicode characters  when writing docstrings, e.g., use α instead of \\alpha. This makes the rendering of the  docstrings in the Documentation and in the Julia REPL's help?> mode as similar as possible.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"You can preview how the Documentation will look like after merging by building the documentation  locally. To do that, from the main directory of your local repository call","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"julia --project=docs/ -e 'using Pkg; Pkg.develop(PackageSpec(path=pwd())); Pkg.instantiate()'\njulia --project=docs/ docs/make.jl","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"and then open docs/build/index.html in your favorite browser.","category":"page"},{"location":"contributing/#Credits","page":"Contributor's guide","title":"Credits","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"This contributor's guide is heavily based on the MetPy contributor's guide  and on its \"cover\" made by Oceananigans.jl.","category":"page"},{"location":"basics/#Code-Basics","page":"Code Basics","title":"Code Basics","text":"","category":"section"},{"location":"basics/","page":"Code Basics","title":"Code Basics","text":"The code solves partial differential equations of the form","category":"page"},{"location":"basics/","page":"Code Basics","title":"Code Basics","text":" partial_t u = Lu + N(u)  ","category":"page"},{"location":"basics/","page":"Code Basics","title":"Code Basics","text":"using Fourier transforms on periodic domains. Above, u(bmx t) is the state variable.  On the right-hand-side, term L u is the 'linear' part of the equation. The term  N(u) is, in general, a 'nonlinear' part.","category":"page"},{"location":"basics/","page":"Code Basics","title":"Code Basics","text":"In FourierFlows.jl, L u is specified by the various modules by prescribing the linear operator L as an array of the same dimension as u. The nonlinear term  N(u) is specified via a function that takes u as its argument.","category":"page"},{"location":"basics/","page":"Code Basics","title":"Code Basics","text":"Boundary conditions in all spatial dimensions are periodic. That allows us to expand all  variables using a Fourier decomposition. For example, if u depends only in one spatial  dimension, x, defined over the domain x in 0 L_x, then:","category":"page"},{"location":"basics/","page":"Code Basics","title":"Code Basics","text":"u(x t) = sum_k_x hatu(k_x t)  e^i k_x x  ","category":"page"},{"location":"basics/","page":"Code Basics","title":"Code Basics","text":"where wavenumbers k_x take the values tfrac2piL_x0pm 1pm 2dots. When we  further consider that x takes discrete values over 0 L_x, e.g., x_j, j = 0 1 dots n_x, then only n_x wavenumbers are independent. By denoting u_j(t) equiv u(x_j t)  and hatu_k(t) equiv hatu(tfrac2piL_x k t) with k an integer, then the  Fourier sum above truncates to:","category":"page"},{"location":"basics/","page":"Code Basics","title":"Code Basics","text":"u_j(t) = sum_k=-n_x2^n_x2-1 hatu_k(t)e^2pi i k x_j  L_x  ","category":"page"},{"location":"basics/","page":"Code Basics","title":"Code Basics","text":"(We assumed here that n_x is even.)","category":"page"},{"location":"basics/","page":"Code Basics","title":"Code Basics","text":"Applying the Fourier transform as above, the partial differential equation transforms to:","category":"page"},{"location":"basics/","page":"Code Basics","title":"Code Basics","text":" partial_t hatu = hatL hatu + widehat N(u)   ","category":"page"},{"location":"basics/","page":"Code Basics","title":"Code Basics","text":"where hatL above denotes the linear operator in Fourier space.","category":"page"},{"location":"basics/","page":"Code Basics","title":"Code Basics","text":"Equations are oftentimes time-stepped forward in Fourier space. Doing so, hatu_k(t)  becomes now our state variable, i.e., the array with all Fourier coefficients of the solution  u. Although time-stepping in Fourier space is by no means a restriction of the code, it  usually enhances performance because it requires less transformations back and forth from  physical to Fourier space and vice versa.","category":"page"},{"location":"installation_instructions/#Installation-instructions","page":"Installation Instructions","title":"Installation instructions","text":"","category":"section"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"You can install the latest version of FourierFlows.jl via the built-in package manager  (accessed by pressing ] in the Julia REPL command prompt) to add the package and also to  instantiate/build all the required dependencies","category":"page"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"julia>]\n(v1.5) pkg> add FourierFlows\n(v1.5) pkg> instantiate","category":"page"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"We recommend installing FourierFlows.jl with the built-in Julia package manager, because  this installs a stable, tagged release. Later on, you can update FourierFlows.jl to the  latest tagged release again via the package manager by typing","category":"page"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"(v1.5) pkg> update FourierFlows","category":"page"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"Note that some releases might induce breaking changes to certain modules. If after anything  happens or your code stops working, please open an issue  or start a discussion. We're  more than happy to help with getting your simulations up and running.","category":"page"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"warn: Use Julia 1.5 or newer\nThe latest FourierFlows.jl requires at least Julia v1.5 to run. Installing FourierFlows with an older version of Julia will install an older version  of FourierFlows.jl (the latest version compatible with your version of Julia).Last version compatible with Julia v1.0.5 (the current long-term-release): FourierFlows.jl v0.4.5","category":"page"},{"location":"library/outline/#Library-Outline","page":"Contents","title":"Library Outline","text":"","category":"section"},{"location":"library/outline/","page":"Contents","title":"Contents","text":"Pages = [\"public.md\", \"internals.md\", \"function_index.md\"]","category":"page"},{"location":"library/internals/#Private-types-and-functions","page":"Private","title":"Private types and functions","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Documentation for FourierFlows.jl's internal interface.","category":"page"},{"location":"library/internals/#FourierFlows","page":"Private","title":"FourierFlows","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [FourierFlows]\nPublic  = false\nPages   = [\"FourierFlows.jl\"]","category":"page"},{"location":"library/internals/#FourierFlows.AbstractDiagnostic","page":"Private","title":"FourierFlows.AbstractDiagnostic","text":"Abstract supertype for diagnostics.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#Problem","page":"Private","title":"Problem","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [FourierFlows]\nPublic  = false\nPages   = [\"problem.jl\"]","category":"page"},{"location":"library/internals/#FourierFlows.Clock","page":"Private","title":"FourierFlows.Clock","text":"Clock{T<:AbstractFloat}\n\nA struct containing the time-step dt, the time t and the step-number of the simulation.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#FourierFlows.EmptyParams","page":"Private","title":"FourierFlows.EmptyParams","text":"EmptyParams <: AbstractParams\n\nA placeholder struct for parameters.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#FourierFlows.EmptyVars","page":"Private","title":"FourierFlows.EmptyVars","text":"EmptyVars <: AbstractVars\n\nA placeholder struct for variables.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#FourierFlows.Equation","page":"Private","title":"FourierFlows.Equation","text":"Equation{T, TL, G<:AbstractFloat}\n\nA struct that includes the equation to be solved ∂u/∂t = L*u + N(u). Array L  includes the coefficients of the linear term L*u and calcN! is a function  which computes the nonlinear term N(u). The struct also includes the problem's grid and the float type of the state vector (and consequently of N(u)).\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#FourierFlows.Equation-Union{Tuple{G}, Tuple{Any,Any,AbstractGrid{G,A} where A}} where G","page":"Private","title":"FourierFlows.Equation","text":"Equation(L, calcN!, grid; dims=supersize(L), T=nothing)\n\nAn equation constructor given the array L of the coefficients of the linear term, the function calcN! that computes the nonlinear term and the problem's  grid.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#FourierFlows.Problem","page":"Private","title":"FourierFlows.Problem","text":"Problem{T, A<:AbstractArray, Tg<:AbstractFloat, TL}\n\nA struct including everything a FourierFlows problem requires: the state vector sol, the clock, the equation eqn, the grid, all problem variables in  vars, problem parameters in params, and the timestepper.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#FourierFlows.Problem-Union{Tuple{T}, Tuple{FourierFlows.Equation,Any,Any,AbstractGrid{T,A} where A}, Tuple{FourierFlows.Equation,Any,Any,AbstractGrid{T,A} where A,Any}, Tuple{FourierFlows.Equation,Any,Any,AbstractGrid{T,A} where A,Any,Any}, Tuple{FourierFlows.Equation,Any,Any,AbstractGrid{T,A} where A,Any,Any,Device}} where T","page":"Private","title":"FourierFlows.Problem","text":"Problem(eqn::Equation, stepper, dt, grid::AbstractGrid,\n        vars=EmptyVars, params=EmptyParams, dev::Device=CPU(); stepperkwargs...)\n\nConstruct a Problem for equation eqn using the timestepper with timestep  dt, on grid and device. Optionally provide variables in vars and parameters with params. The stepperkwargs are passed to the time-stepper constructor.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#Domain","page":"Private","title":"Domain","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [FourierFlows]\nPublic  = false\nPages   = [\"domains.jl\"]","category":"page"},{"location":"library/internals/#FourierFlows.getaliasedwavenumbers-Tuple{Any,Any,Any}","page":"Private","title":"FourierFlows.getaliasedwavenumbers","text":"getaliasedwavenumbers(nk, nkr, aliasfraction)\n\nReturns the top aliasfraction highest wavenumbers.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#FourierFlows.griddevice-Union{Tuple{AbstractGrid{T,A}}, Tuple{A}, Tuple{T}} where A where T","page":"Private","title":"FourierFlows.griddevice","text":"griddevice(grid)\n\nReturns the device on which the grid lives on.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#FourierFlows.makefilter-Tuple{Array}","page":"Private","title":"FourierFlows.makefilter","text":"makefilter(K; order=4, innerK=0.65, outerK=1)\n\nReturns a filter acting on the non-dimensional wavenumber K that decays exponentially for K>innerK, thus removing high-wavenumber content from a spectrum it is multiplied with. The decay rate is determined by order and outerK determines the outer wavenumber at which the filter is smaller than Float64 machine precision.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#Utilities","page":"Private","title":"Utilities","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [FourierFlows]\nPublic  = false\nPages   = [\"utils.jl\"]","category":"page"},{"location":"library/internals/#FourierFlows.jacobian-Tuple{Any,Any,TwoDGrid}","page":"Private","title":"FourierFlows.jacobian","text":"jacobian(a, b, grid)\n\nReturns the Jacobian of a and b on grid.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#FourierFlows.jacobianh-Tuple{Any,Any,TwoDGrid}","page":"Private","title":"FourierFlows.jacobianh","text":"jacobianh(a, b, grid)\n\nReturns the Fourier transform of the Jacobian of a and b on grid.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#FourierFlows.on_grid-Union{Tuple{A}, Tuple{T}, Tuple{Any,OneDGrid{T,A,Tx,Tfft,Trfft} where Trfft where Tfft where Tx}} where A where T","page":"Private","title":"FourierFlows.on_grid","text":"on_grid(func, grid)\n\nReturns an array, of the ArrayType of the device grid lives on, that contains the values of function func evaluated on the grid.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#FourierFlows.parsevalsum-Tuple{Any,TwoDGrid}","page":"Private","title":"FourierFlows.parsevalsum","text":"parsevalsum(uh, grid)\n\nReturns real(Σ uh) on the grid.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#FourierFlows.parsevalsum2-Tuple{Any,TwoDGrid}","page":"Private","title":"FourierFlows.parsevalsum2","text":"parsevalsum2(uh, grid)\n\nReturns ∫ u² dxdy = Σ|uh|² on the grid. More specifically, it returns\n\nint u(boldsymbolx)^2  mathrmd^2 boldsymbolx = sum_boldsymbolk hatu_boldsymbolk^2 L_x L_y\n\nwhere hatu_boldsymbolk = uh / grid.nx. \n\n\n\n\n\n","category":"method"},{"location":"library/internals/#FourierFlows.radialspectrum-Tuple{Any,TwoDGrid}","page":"Private","title":"FourierFlows.radialspectrum","text":"radialspectrum(ah, grid; n=nothing, m=nothing, refinement=2)\n\nReturns aρ = ∫ ah(ρ, θ) ρ dρ dθ, the radial spectrum of ah known on the Cartesian wavenumber grid (k, l).\n\naρ is found by intepolating ah onto a polar wavenumber grid (ρ, θ), and then integrating over θ to find aρ. The default resolution (n, m) for the polar wave number grid is n=refinement * maximum(nk, nl), m = refinement * maximum(nk, nl), where refinement = 2 by default. If ah is in conjugate symmetric form only the upper half plane in θ is represented on the polar grid.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#Diagnostics","page":"Private","title":"Diagnostics","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [FourierFlows]\nPublic  = false\nPages   = [\"diagnostics.jl\"]","category":"page"},{"location":"library/internals/#Base.getindex-Tuple{Diagnostic,Union{AbstractString, Symbol}}","page":"Private","title":"Base.getindex","text":"e.g. plot(energydiag[:t], energydiag[:data]).\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#FourierFlows.extend!-Tuple{Any,Any}","page":"Private","title":"FourierFlows.extend!","text":"extend!(diag::AbstractDiagnostic, n)\n\nExtend the data, time, and steps vectors of diag by n.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#Output","page":"Private","title":"Output","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [FourierFlows]\nPublic  = false\nPages   = [\"output.jl\"]","category":"page"},{"location":"library/internals/#FourierFlows.savefield-Tuple{Any,Any,Any}","page":"Private","title":"FourierFlows.savefield","text":"savefield(file, location, data)\n\nSaves a particular field.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#FourierFlows.savefields-Tuple{JLD2.JLDFile{JLD2.MmapIO},TwoDGrid}","page":"Private","title":"FourierFlows.savefields","text":"savefields(file, field)\n\nSaves some parameters of prob.field.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#FourierFlows.uniquepath-Tuple{Any}","page":"Private","title":"FourierFlows.uniquepath","text":"uniquepath(path)\n\nReturns path with a number appended if isfile(path), incremented until path does not exist.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#Timesteppers","page":"Private","title":"Timesteppers","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [FourierFlows]\nPublic = false\nPages   = [\"timesteppers.jl\"]","category":"page"},{"location":"library/internals/#FourierFlows.getetdcoeffs-Tuple{Any,Any}","page":"Private","title":"FourierFlows.getetdcoeffs","text":"getetdcoeffs(dt, L; ncirc=32, rcirc=1)\n\nCalculate ETDRK4 coefficients associated with the (diagonal) linear coefficient L by integrating over a small circle in complex space.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#Diffusion-Testbed-Module","page":"Private","title":"Diffusion Testbed Module","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [FourierFlows.Diffusion]\nPublic  = false\nPages   = [\"diffusion.jl\"]","category":"page"},{"location":"library/internals/#FourierFlows.Diffusion.Vars-Union{Tuple{T}, Tuple{Dev}, Tuple{Dev,AbstractGrid{T,A} where A}} where T where Dev","page":"Private","title":"FourierFlows.Diffusion.Vars","text":"Vars(dev, grid)\n\nReturns the variables vars for a constant diffusivity problem on grid.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#FourierFlows.Diffusion.Equation-Union{Tuple{T}, Tuple{Device,T,Any}} where T<:Number","page":"Private","title":"FourierFlows.Diffusion.Equation","text":"Equation(dev, κ, grid)\n\nReturns the equation for a constant diffusivity problem on grid with diffusivity κ.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#FourierFlows.Diffusion.calcN!-Union{Tuple{T}, Tuple{Any,Any,Any,Any,Any,FourierFlows.Diffusion.Params{T},Any}} where T<:Number","page":"Private","title":"FourierFlows.Diffusion.calcN!","text":"calcN!(N, sol, t, clock, vars, params, grid)\n\nCalculate the nonlinear term for the 1D heat equation.\n\n\n\n\n\n","category":"method"},{"location":"grids/#Grids","page":"Grids","title":"Grids","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"1D, 2D, and 3D grids are supported. We demonstrate here the construction of a  one-dimensional grid and how one can use it to perform Fourier transforms and  compute spatial derivatives.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"A one-dimensional grid with n_x = 64 grid points and length L_x = 2 pi is  constructed by","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"DocTestSetup = quote\n    using FourierFlows\nend","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"julia> using FourierFlows\n\njulia> nx, Lx = 64, 2π;\n\njulia> grid = OneDGrid(nx, Lx)\nOneDimensionalGrid\n  ├─────────── Device: CPU\n  ├──────── FloatType: Float64\n  ├────────── size Lx: 6.283185307179586\n  ├──── resolution nx: 64\n  ├── grid spacing dx: 0.09817477042468103\n  └─────────── domain: x ∈ [-3.141592653589793, 3.0434178831651124]","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"The grid domain is, by default, constructed symmetrically around x = 0, but this  can be altered using the x0 keyword argument of OneDGrid constructor. The grid  spacing is L_x  n_x. Note that the last point of the domain is a grid-spacing  before L_x  2. This is because periodicity implies that the values of any field  at the end-points of the domain are equal and, therefore, grid-point values at both these end-points are reduntant.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"We can define an array u that contains the values of a function u(x) on this  grid as","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"using FourierFlows\nusing LinearAlgebra: mul!, ldiv!\nusing Plots\nPlots.scalefontsizes(1.25)\nPlots.default(lw=3)\nnx, Lx = 64, 2π\ngrid = OneDGrid(nx, Lx)","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"u = @. sin(2 * grid.x) + 1/2 * cos(5 * grid.x)\n\nnothing # hide","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"Note that we chose a function that is periodic on our domain. We can visualize u by","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"using Plots\n\nplot(grid.x, u, label=\"u\", xlabel=\"x\")\nsavefig(\"assets/plot1.svg\"); nothing # hide","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"(Image: )","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"Function u(x) can be expanded in Fourier series:","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"u(x) = sum_k hatu(k)  e^i k x ","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"where hatu(k) is Fourier transform of u(x) and k the discrete set of  wavenumbers that fit within our finite domain. We can compute hatu via a  Fast Fourier Transform (FFT). Since our u array is real-valued then we should  use the real-FFT algorithm. The real-valued FFT transform only saves the Fourier  coefficients for k ge 0; the coefficients for negative wavenumbers can be  obtained via hatu(-k) = hatu(k)^*.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"The wavenumbers used in FFT are contained in grid.k and they are ordered as:","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"frac2piL_x  0 1 dots n_x2-1 -n_x2 -n_x2+1 dots -1  ","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"while the wavenumbers for real FFT are in grid.kr:","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"frac2piL_x  0 1 dots n_x2-1  ","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"The grid also includes the FFT plans for both real-valued and complex valued transforms:","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"grid.fftplan","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"grid.rfftplan","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"We use the convention that variables names with h at the end stand for variable-hat, i.e.,  hatu  is the Fourier transform of u and is stored in array uh. Since u is of  size n_x, the real-Fourier transform should be of size n_kr = n_x2+1.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"uh = Complex.(zeros(grid.nkr))\n\nnothing # hide","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"The FFT transform is done as an in-place matrix multiplication using mul!.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"using LinearAlgebra: mul!\n\nmul!(uh, grid.rfftplan, u)\n\nnothing # hide","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"The FFT algorithm does not output exactly the Fourier coefficients hatu(k) but rather due to different normalization, FFT outputs something proportional to hatu(k).  To obtain hatu we need to divide the FFT output by the length of the  original array and by e^-i k x_0, where x_0 is the first  point of our domain array.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"uhat = @. uh / (nx * exp(- im * grid.kr * grid.x[1])) # due to normalization of FFT\n\nplot(grid.kr, [real.(uhat), imag.(uhat)],\n          label = [\"real( û )\" \"imag( û )\"],\n         xlabel = \"k\",\n          xlims = (-0.5, 10.5),\n          ylims = (-0.55, 0.55),\n         xticks = 0:10,\n         yticks = -0.5:0.25:0.5,\n         marker = :auto)\n\nsavefig(\"assets/plot2.svg\"); nothing # hide","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"(Image: )","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"We can compute its derivative via Fourier transforms. To do that we can use the FFTW plans that are constructed with the grid. First we allocate some empty arrays where the values of the derivative in physical and Fourier space will be stored,","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"∂ₓu  = similar(u)\n∂ₓuh = similar(uh)\nnothing # hide","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"The grid contains the wavenumbers (both for real-value functions grid.kr and  for complex-valued functions grid.k). We populate array ∂ₓuh is with i k hatu:","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"@. ∂ₓuh = im * grid.kr * uh\n\nnothing # hide","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"Then the derivative in physical space, ∂ₓu, is obtained with an inverse Fourier  tranform. The latter is obtained again using the FFTW plans but now via ldiv!:","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"using LinearAlgebra: ldiv!\n\nldiv!(∂ₓu, grid.rfftplan, ∂ₓuh)\n\nplot(grid.x, [u ∂ₓu], label=[\"u\" \"∂u/∂x\"], xlabel=\"x\")\n\nsavefig(\"assets/plot3.svg\"); nothing # hide","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"(Image: )","category":"page"},{"location":"library/function_index/#main-index","page":"Function index","title":"Index","text":"","category":"section"},{"location":"library/function_index/","page":"Function index","title":"Function index","text":"Pages = [\"public.md\", \"internals.md\", \"function_index.md\"]","category":"page"},{"location":"problem/#Problem","page":"Problem","title":"Problem","text":"","category":"section"},{"location":"problem/","page":"Problem","title":"Problem","text":"using FourierFlows, Plots\nusing LinearAlgebra: mul!, ldiv!\nPlots.scalefontsizes(1.25)\nPlots.default(lw=2)","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"Everything needed to solve a PDE in FourierFlows.jl is gathered in a Problem struct. T he Problem struct contains various other structs, namely:","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"grid (grid),\nparameters (params),\nvariables (vars),\nequation details (eqn),\ntimestepper (timestepper),\nclock (clock), and\nstate vector (sol).","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"Here, we demonstrate how we can construct such a Problem struct to solve the simple 1D  equation:","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"partial_t u(x t) = - alpha  u(x t) ","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"on domain x in -1 1.","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"First, we construct our grid","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"using FourierFlows\n\nnx, Lx = 32, 2.0\n\ngrid = OneDGrid(nx, Lx)","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"Our problem has a parameter alpha. We create a Params struct by:","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"struct Params <: AbstractParams\n  α :: Float64\nend","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"and then we use the struct's constructor to populate our struct with the parameter value,  e.g., alpha = 01:","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"α = 0.1\n\nparams = Params(α)","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"The particular equation is so simple that it makes no difference performance-wise whether  we time-step it in physical or in wavenumber space. For PDEs with nonlinear terms,  time-stepping in wavenumber space is much more efficient. Thus, for demonstration purposes,  we will time-step the equation in wavenumber space, i.e.,","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"partial_t hatu(k t) = - alpha  hatu(k t) ","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"The variables involved are u and its Fourier transform hatu. Thus, we  construct the vars struct as:","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"struct Vars <: AbstractVars\n    u :: Array{Float64,1}\n   uh :: Array{Complex{Float64}, 1}\nend","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"and, like before, we use the struct's constructor to populate the struct with  zero arrays,","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"vars = Vars(zeros(Float64, (grid.nx,)), zeros(Complex{Float64}, (grid.nkr,)))","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"Note that the Fourier transform of a real-valued array u is complex-valued. Also because we use the real Fourier transform, the array uh is smaller.","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"In this simple example our state variable is simply uh, i.e., sol = uh.","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"Next we need to construct the equation struct. Equation contains the linear  coefficients for the linear part of the PDE, stored in an array L, and the  function calcN!() that  calculates the nonlinear terms from the state variable  sol. In our case, our equation is linear and, therefore,","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"L = - params.α * ones(grid.nkr)\n\nnothing # hide","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"and","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"function calcN!(N, sol, t, clock, vars, params, grid)\n  @. N = 0\n  \n  return nothing\nend\n\nnothing # hide","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"Note that calcN!() needs to have the above argument structure. With L and calcN! in hand we can construct our problem's equation:","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"equation = FourierFlows.Equation(L, calcN!, grid)","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"Last, we have to pick a time-stepper and a time-step dt and gather everything  a problem struct:","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"stepper, dt = \"ForwardEuler\", 0.01\n\nprob = FourierFlows.Problem(equation, stepper, dt, grid, vars, params)","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"Currently, the implemented time-steppers are ForwardEuler, AB3 (Adams-Basmforth 3rd order),  RK4 (Runge-Kutta 4th order), and ETDRK4 (Exponential Time Differencing Runge-Kutta 4th order). Also, there exist the Filtered versions of all the above, in which a high-wavenumber filter is applied after every time-step.","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"By default, the Problem contructor takes sol a complex valued array same  size as L filed with zeros.","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"The problem.clock contains the time-step dt and the current step and time  t of the simulation:","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"prob.clock","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"Let's initiate our problem with, e.g., u(x 0) = cos(pi x), integrate up  to t = 2 and compare our numerical solution with the analytic solution  u(x t) = e^-alpha t cos(pi x).","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"u0 = @. cos(π * grid.x)\n\nusing LinearAlgebra: mul!\n\nmul!(prob.sol, grid.rfftplan, u0)\n\nnothing # hide","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"Since our time-step is chosen dt = 0.01, we need to step forward prob for 200  time-steps to reach t = 2.","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"stepforward!(prob, 200)","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"Now let's transform our state vector sol back in physical space","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"using LinearAlgebra: ldiv!\n\nldiv!(prob.vars.u, grid.rfftplan, prob.sol)\n\nnothing # hide","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"and finally, let's plot our solution and compare with the analytic solution:","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"using Plots\n\nplot(grid.x, prob.vars.u,\n     seriestype = :scatter,\n          label = \"numerical\",         \n         xlabel = \"x\",\n          title = \"u(x, t=\" * string(round(prob.clock.t, digits=2)) * \")\")\n\nplot!(x -> cos(π * x) * exp(-prob.params.α * 2), -1, 1, label = \"analytical\")\n\nplot!(x -> cos(π * x), -1, 1, linestyle=:dash, color=:gray, label = \"initial condition\")\n\nsavefig(\"assets/plot4.svg\"); nothing # hide","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"(Image: )","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"A good practice is to encompass all functions and type definitions related with a PDE under  a single module, e.g.,","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"module mypde\n\n...\n\nend # end module","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"For a more elaborate example we urge you to have a look at the Diffusion  module located at src/diffusion.jl and also to the modules included in the  child package GeophysicalFlows.jl.","category":"page"},{"location":"gpu/#GPU","page":"GPU","title":"GPU","text":"","category":"section"},{"location":"gpu/","page":"GPU","title":"GPU","text":"FourierFlows allows you to easily construct and run problems on GPUs.","category":"page"},{"location":"gpu/","page":"GPU","title":"GPU","text":"Upon calling","category":"page"},{"location":"gpu/","page":"GPU","title":"GPU","text":"using FourierFlows","category":"page"},{"location":"gpu/","page":"GPU","title":"GPU","text":"FourierFlows.jl will check whether any CUDA enabled device is present. If such a device is  found then FourierFlows.jl makes sure that CUDA related packages are loaded and also it will  overload all methods to work with GPU() device as their argument (instead of the standard  CPU() device).","category":"page"},{"location":"gpu/","page":"GPU","title":"GPU","text":"It's easy to construct a grid that lives on the GPU. Calling:","category":"page"},{"location":"gpu/","page":"GPU","title":"GPU","text":"dev = GPU()\nn, L = 16, 2.0\ngrid = OneDGrid(dev, n, L)\n\nOneDimensionalGrid\n  ├─────────── Device: GPU\n  ├──────── FloatType: Float64\n  ├────────── size Lx: 2.0\n  ├──── resolution nx: 16\n  ├── grid spacing dx: 0.125\n  └─────────── domain: x ∈ [-1.0, 0.875]","category":"page"},{"location":"gpu/","page":"GPU","title":"GPU","text":"gives out a grid whose arrays are CuArrays. (Calling OneDGrid(n, L) defaults to CPU, i.e.,  OneDGrid(CPU(), n, L).)","category":"page"},{"location":"gpu/","page":"GPU","title":"GPU","text":"When we construct the Params, Vars, and Equation for our problem we need to make sure that we create arrays on the appropriate device, i.e., Arrays for CPU or CuArrays for the GPU. Function ArrayType is useful in constructing appropriately chosen arrays.","category":"page"},{"location":"gpu/","page":"GPU","title":"GPU","text":"ArrayType","category":"page"},{"location":"gpu/#FourierFlows.ArrayType","page":"GPU","title":"FourierFlows.ArrayType","text":"ArrayType(::Device)\nArrayType(::Device, T, dim)\n\nReturns the proper array type according to the Device chosen, i.e., Array for CPU and CuArray for GPU.\n\n\n\n\n\n","category":"function"},{"location":"gpu/","page":"GPU","title":"GPU","text":"The FourierFlows.Problem constructor then takes an optional positional argument  dev::Device If not provided anything, the default values for dev=CPU().","category":"page"},{"location":"gpu/","page":"GPU","title":"GPU","text":"problem = Problem(equation, stepper, dt, grid, vars, params, GPU())","category":"page"},{"location":"gpu/","page":"GPU","title":"GPU","text":"The FourierFlows.Diffusion module is written in a way such that switching from CPU to GPU  is only a matter of calling FourierFlows.Diffusion.Problem() with dev=GPU(). All physics  modules in GeophysicalFlows.jl can  also seamlessly run on a GPU with dev=GPU() argument.","category":"page"},{"location":"gpu/#Selecting-GPU-device","page":"GPU","title":"Selecting GPU device","text":"","category":"section"},{"location":"gpu/","page":"GPU","title":"GPU","text":"FourierFlows.jl can only utilize a single GPU. If your machine has more than one GPU available,  then functionality within CUDA.jl package enables the user to choose the GPU device that  FourierFlows.jl should use. The user is referred to the CUDA.jl Documentation; in particular, CUDA.devices and CUDA.CuDevice.","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"EditURL = \"https://github.com/FourierFlows/FourierFlowsDocumentation/blob/master/examples/OneDShallowWaterGeostrophicAdjustment.jl\"","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/#Linear-rotating-shallow-water-dynamics","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"","category":"section"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"This example can be run online via (Image: ). Also, it can be viewed as a Jupyter notebook via (Image: ).","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"This example solves the linear 1D rotating shallow water equations for the u(x t), v(x t) and the surface surface elevation eta(x t), for a fluid with constant rest-depth H. That is, the total fluid's depth is H + eta(x t) with eta ll H.","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"The linearized equations for the evolution of u, v, eta are:","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"beginaligned\nfracpartial upartial t - f v  = - g fracpartial etapartial x - mathrmD u \nfracpartial vpartial t + f u  = - mathrmD v \nfracpartial etapartial t + H fracpartial upartial x  = - mathrmD eta\nendaligned","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"Above, g is the gravitational acceleration, f is the  Coriolis parameter, and mathrmD indicates a hyperviscous linear operator of the form (-1)^n_ν ν nabla^2 n_ν, with ν the viscosity coefficient and n_ν the order of the operator.","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"Rotation introduces the deformation length scale, L_d = sqrtg H  f. Disturbances with length scales much smaller than L_d don't \"feel\" the rotation and propagate as inertia-gravity waves. Disturbances with length scales comparable or larger than L_d should be approximately in geostrophic balance, i.e., the Coriolis acceleration f widehatbmz times bmu should be in approximate balance with the pressure gradient -g bmnabla eta.","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"using FourierFlows, Plots, Printf, Random\nusing LinearAlgebra: mul!, ldiv!","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/#Coding-up-the-equations","page":"Linear rotating shallow water dynamics","title":"Coding up the equations","text":"","category":"section"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/#A-demonstration-of-FourierFlows.jl-framework","page":"Linear rotating shallow water dynamics","title":"A demonstration of FourierFlows.jl framework","text":"","category":"section"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"What follows is a step-by-step tutorial demonstrating how you can create your own solver for an equation of your liking.","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"The basic building blocks for a FourierFlows.Problem() are:","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"Grid struct containining the physical and wavenumber grid for the problem,\nParams struct containining all the parameters of the problem,\nVars struct containining arrays with the variables used in the problem,\nEquation struct containining the coefficients of the linear operator L and the function that computes the nonlinear terms, usually named calcN!().","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"The Grid structure is provided by FourierFlows.jl. One simply has to call one of the OneDGrid(), TwoDGrid(), or ThreeDGrid() grid constructors, depending on the dimensionality of the problem. All other structs mentioned above are problem-specific and need to be constructed for every set of equations we want to solve.","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"First lets construct the Params struct that contains all parameters of the problem","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"struct Params{T} <: AbstractParams\n   ν :: T         # Hyperviscosity coefficient\n  nν :: Int       # Order of the hyperviscous operator\n   g :: T         # Gravitational acceleration\n   H :: T         # Fluid depth\n   f :: T         # Coriolis parameter\nend\nnothing #hide","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"Now the Vars struct that contains all variables used in this problem. For this problem Vars includes the representations of the flow fields in physical space u, v and η and their Fourier transforms uh, vh, and ηh.","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"struct Vars{Aphys, Atrans} <: AbstractVars\n   u :: Aphys\n   v :: Aphys\n   η :: Aphys\n  uh :: Atrans\n  vh :: Atrans\n  ηh :: Atrans\nend\nnothing #hide","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"A constructor populates empty arrays based on the dimension of the grid and then creates Vars struct.","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"\"\"\"\n    Vars(dev, grid)\nConstructs Vars for 1D shallow water based on the dimensions of arrays of the `grid`.\n\"\"\"\nfunction Vars(::Dev, grid) where Dev\n  T = eltype(grid)\n  @devzeros Dev T grid.nx u v η\n  @devzeros Dev Complex{T} grid.nkr uh vh ηh\n\n  return Vars(u, v, η, uh, vh, ηh)\nend\nnothing #hide","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"In Fourier space, the 1D linear shallow water dynamics read:","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"beginaligned\nfracpartial hatupartial t  = underbrace f hatv - i k g hateta _N_u  underbrace- nu k^2 _L_u hatu  \nfracpartial hatvpartial t  = underbrace - f hatu _N_v  underbrace- nu k^2 _L_v hatv  \nfracpartial hatetapartial t  = underbrace - i k H hatu _N_eta  underbrace- nu k^2 _L_eta hateta \nendaligned","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"Although, e.g., terms involving the Coriolis accelaration are, in principle, linear we include them in the nonlinear term N because they render the linear operator L non-diagonal.","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"With these in mind, we construct function calcN! that computes the nonlinear terms.","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"\"\"\"\n    calcN!(N, sol, t, clock, vars, params, grid)\nCompute the nonlinear terms for 1D linear shallow water dynamics.\n\"\"\"\nfunction calcN!(N, sol, t, clock, vars, params, grid)\n  @. vars.uh = sol[:, 1]\n  @. vars.vh = sol[:, 2]\n  @. vars.ηh = sol[:, 3]\n\n  @. N[:, 1] =   params.f * vars.vh - im * grid.kr * params.g * vars.ηh    #  + f v - g ∂η/∂x\n  @. N[:, 2] = - params.f * vars.uh                                        #  - f u\n  @. N[:, 3] = - im * grid.kr * params.H * vars.uh                         #  - H ∂u/∂x\n\n  dealias!(N, grid, grid.kralias)\n\n  return nothing\nend\nnothing #hide","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"Next we construct the Equation struct:","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"\"\"\"\n    Equation(dev, params, grid)\nConstruct the equation: the linear part, in this case the hyperviscous dissipation,\nand the nonlinear part, which is computed by `calcN!` function.\n\"\"\"\nfunction Equation(dev, params, grid)\n  T = eltype(grid)\n  L = zeros(dev, T, (grid.nkr, 3))\n  D = @. - params.ν * grid.kr^(2*params.nν)\n\n  L[:, 1] .= D # for u equation\n  L[:, 2] .= D # for v equation\n  L[:, 3] .= D # for η equation\n\n  return FourierFlows.Equation(L, calcN!, grid)\nend\nnothing #hide","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"We now have all necessary building blocks to construct a FourierFlows.Problem. It would be useful, however, to define some more \"helper functions\". For example, a function that updates all variables given the solution sol which comprises hatu, hatv and hateta:","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"\"\"\"\n    updatevars!(prob)\nUpdate the variables in `prob.vars` using the solution in `prob.sol`.\n\"\"\"\nfunction updatevars!(prob)\n  vars, grid, sol = prob.vars, prob.grid, prob.sol\n\n  @. vars.uh = sol[:, 1]\n  @. vars.vh = sol[:, 2]\n  @. vars.ηh = sol[:, 3]\n\n  ldiv!(vars.u, grid.rfftplan, deepcopy(sol[:, 1])) # use deepcopy() because irfft destroys its input\n  ldiv!(vars.v, grid.rfftplan, deepcopy(sol[:, 2])) # use deepcopy() because irfft destroys its input\n  ldiv!(vars.η, grid.rfftplan, deepcopy(sol[:, 3])) # use deepcopy() because irfft destroys its input\n\n  return nothing\nend\nnothing #hide","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"Another useful function is one that prescribes an initial condition to the state variable sol.","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"\"\"\"\n    set_uvη!(prob, u0, v0, η0)\nSets the state variable `prob.sol` as the Fourier transforms of `u0`, `v0`, and `η0`\nand update all variables in `prob.vars`.\n\"\"\"\nfunction set_uvη!(prob, u0, v0, η0)\n  vars, grid, sol = prob.vars, prob.grid, prob.sol\n\n  A = typeof(vars.u) # determine the type of vars.u\n\n  mul!(vars.uh, grid.rfftplan, A(u0)) # A(u0) converts u0 to the same type as vars expects (useful if u0 is a CPU array while working on the GPU)\n  mul!(vars.vh, grid.rfftplan, A(v0)) # A(v0) converts u0 to the same type as vars expects (useful if v0 is a CPU array while working on the GPU)\n  mul!(vars.ηh, grid.rfftplan, A(η0)) # A(η0) converts u0 to the same type as vars expects (useful if η0 is a CPU array while working on the GPU)\n\n  @. sol[:, 1] = vars.uh\n  @. sol[:, 2] = vars.vh\n  @. sol[:, 3] = vars.ηh\n\n  updatevars!(prob)\n\n  return nothing\nend\nnothing #hide","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/#Let's-prescibe-parameter-values-and-solve-the-PDE","page":"Linear rotating shallow water dynamics","title":"Let's prescibe parameter values and solve the PDE","text":"","category":"section"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"We are now ready to write up a program that sets up parameter values, constructs the problem prob, # time steps the solutions prob.sol and plots it.","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/#Choosing-a-device:-CPU-or-GPU","page":"Linear rotating shallow water dynamics","title":"Choosing a device: CPU or GPU","text":"","category":"section"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"dev = CPU()    # Device (CPU/GPU)\nnothing # hide","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/#Numerical-parameters-and-time-stepping-parameters","page":"Linear rotating shallow water dynamics","title":"Numerical parameters and time-stepping parameters","text":"","category":"section"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"     nx = 512            # grid resolution\nstepper = \"FilteredRK4\"  # timestepper\n     dt = 20.0           # timestep (s)\n nsteps = 320            # total number of time-steps\nnothing # hide","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/#Physical-parameters","page":"Linear rotating shallow water dynamics","title":"Physical parameters","text":"","category":"section"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"Lx = 500e3      # Domain length (m)\ng  = 9.8        # Gravitational acceleration (m s⁻²)\nH  = 200.0      # Fluid depth (m)\nf  = 1e-2       # Coriolis parameter (s⁻¹)\nν  = 100.0      # Viscosity (m² s⁻¹)\nnν = 1          # Viscosity order (nν = 1 means Laplacian ∇²)\nnothing # hide","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/#Construct-the-structs-and-you-are-ready-to-go!","page":"Linear rotating shallow water dynamics","title":"Construct the structs and you are ready to go!","text":"","category":"section"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"Create a grid and also params, vars, and the equation structs. Then give them all as input to the FourierFlows.Problem() constructor to get a problem struct, prob, that contains all of the above.","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"    grid = OneDGrid(dev, nx, Lx)\n  params = Params(ν, nν, g, H, f)\n    vars = Vars(dev, grid)\nequation = Equation(dev, params, grid)\n\n    prob = FourierFlows.Problem(equation, stepper, dt, grid, vars, params, dev)\nnothing #hide","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/#Setting-initial-conditions","page":"Linear rotating shallow water dynamics","title":"Setting initial conditions","text":"","category":"section"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"For initial condition we take the fluid at rest (u = v = 0). The free surface elevation is perturbed from its rest position (eta=0); the disturbance we impose a Gaussian bump with half-width greater than the deformation radius and on top of that we superimpose some random noise with scales smaller than the deformation radius. We mask the small-scale perturbations so that it only applies in the central part of the domain by applying","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"The system develops geostrophically-balanced jets around the Gaussian bump, while the smaller-scale noise propagates away as inertia-gravity waves.","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"First let's construct the Gaussian bump.","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"gaussian_width = 6e3\ngaussian_amplitude = 3.0\ngaussian_bump = @. gaussian_amplitude * exp( - grid.x^2 / (2*gaussian_width^2) )\n\nplot(grid.x/1e3, gaussian_bump,    # divide with 1e3 to convert m -> km\n     color = :black,\n    legend = false,\n linewidth = 2,\n     alpha = 0.7,\n     xlims = (-Lx/2e3, Lx/2e3),\n    xlabel = \"x [km]\",\n    ylabel = \"η [m]\",\n     title = \"A gaussian bump with half-width ≈ \"*string(gaussian_width/1e3)*\" km\",\n      size = (600, 260))","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"Next the noisy perturbation. The mask is simply a product of hyperbolic tangent functions.","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"mask = @. 1/4 * (1 + tanh( -(grid.x - 100e3) / 10e3)) * (1 + tanh( (grid.x + 100e3) / 10e3))\n\nnoise_amplitude = 0.1 # the amplitude of the noise for η(x,t=0) (m)\nη_noise = noise_amplitude * Random.randn(size(grid.x))\n@. η_noise *= mask    # mask the noise\n\nplot_noise = plot(grid.x/1e3, η_noise,      # divide with 1e3 to convert m -> km\n                 color = :black,\n                legend = :false,\n             linewidth = [3 2],\n                 alpha = 0.7,\n                 xlims = (-Lx/2e3, Lx/2e3), # divide with 1e3 to convert m -> km\n                 ylims = (-0.3, 0.3),\n                xlabel = \"x [km]\",\n                ylabel = \"η [m]\")\n\nplot_mask = plot(grid.x/1e3, mask,          # divide with 1e3 to convert m -> km\n                 color = :gray,\n                legend = :false,\n             linewidth = [3 2],\n                 alpha = 0.7,\n                 xlims = (-Lx/2e3, Lx/2e3), # divide with 1e3 to convert m -> km\n                xlabel = \"x [km]\",\n                ylabel = \"mask\")\n\ntitle = plot(title = \"Small-scale noise\",\n              grid = false,\n          showaxis = false,\n            xticks = [],\n            yticks = [],\n     bottom_margin = -20Plots.px)\n\nplot(title, plot_noise, plot_mask,\n           layout = @layout([A{0.01h}; [B; C]]),\n             size = (600, 400))","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"Sum the Gaussian bump and the noise and then call set_uvη!() to set the initial condition to the problem prob.","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"η0 = @. gaussian_bump + η_noise\nu0 = zeros(grid.nx)\nv0 = zeros(grid.nx)\n\nset_uvη!(prob, u0, v0, η0)\n\nplot(grid.x/1e3, η0,    # divide with 1e3 to convert m -> km\n     color = :black,\n    legend = false,\n linewidth = 2,\n     alpha = 0.7,\n     xlims = (-Lx/2e3, Lx/2e3),\n    xlabel = \"x [km]\",\n    ylabel = \"η [m]\",\n     title = \"initial surface elevation, η(x, t=0)\",\n      size = (600, 260))","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/#Visualizing-the-simulation","page":"Linear rotating shallow water dynamics","title":"Visualizing the simulation","text":"","category":"section"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"We define a function that plots the surface elevation eta and the depth-integrated velocities u and v.","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"function plot_output(prob)\n  plot_η = plot(grid.x/1e3, vars.η,         # divide with 1e3 to convert m -> km\n                 color = :blue,\n                legend = false,\n             linewidth = 2,\n                 alpha = 0.7,\n                 xlims = (-Lx/2e3, Lx/2e3), # divide with 1e3 to convert m -> km\n                xlabel = \"x [km]\",\n                ylabel = \"η [m]\")\n\n  plot_u = plot(grid.x/1e3, vars.u,         # divide with 1e3 to convert m -> km\n                 color = :red,\n                legend = false,\n             linewidth = 2,\n                 alpha = 0.7,\n                 xlims = (-Lx/2e3, Lx/2e3), # divide with 1e3 to convert m -> km\n                 ylims = (-0.3, 0.3),\n                xlabel = \"x [km]\",\n                ylabel = \"u [m s⁻¹]\")\n\n  plot_v = plot(grid.x/1e3, vars.v,         # divide with 1e3 to convert m -> km\n                 color = :green,\n                legend = false,\n             linewidth = 2,\n                 alpha = 0.7,\n                 xlims = (-Lx/2e3, Lx/2e3), # divide with 1e3 to convert m -> km\n                 ylims = (-0.3, 0.3),\n                xlabel = \"x [km]\",\n                ylabel = \"v [m s⁻¹]\")\n\n  Ld = @sprintf \"%.2f\" sqrt(g*H)/f /1e3     # divide with 1e3 to convert m -> km\n  plottitle = \"Deformation radius √(gh) / f = \"*string(Ld)*\" km\"\n\n  title = plot(title = plottitle,\n                grid = false,\n            showaxis = false,\n              xticks = [],\n              yticks = [],\n       bottom_margin = -30Plots.px)\n\n  return plot(title, plot_η, plot_u, plot_v,\n           layout = @layout([A{0.01h}; [B; C; D]]),\n             size = (600, 800))\nend\nnothing # hide","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/#Time-stepping-the-Problem-forward","page":"Linear rotating shallow water dynamics","title":"Time-stepping the Problem forward","text":"","category":"section"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"We time-step the Problem forward in time. We update variables by calling updatevars!() and we also update the plot. We enclose the for loop in an @animate macro to produce an animation of the solution.","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"p = plot_output(prob)\n\nanim = @animate for j = 0:nsteps\n  updatevars!(prob)\n\n  p[2][1][:y] = vars.η    # updates the plot for η\n  p[2][:title] = \"t = \" * @sprintf(\"%.1f\", prob.clock.t/60) * \" min\" # updates time in the title\n  p[3][1][:y] = vars.u    # updates the plot for u\n  p[4][1][:y] = vars.v    # updates the plot for v\n\n  stepforward!(prob)\nend\n\nmp4(anim, \"onedshallowwater.mp4\", fps=18)","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/#Geostrophic-balance","page":"Linear rotating shallow water dynamics","title":"Geostrophic balance","text":"","category":"section"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"It is instructive to compare the solution for v with its geostrophically balanced approximation, f widehatbmz times bmu_rm geostrophic = - g bmnabla eta, i.e.,","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"beginaligned\nv_rm geostrophic  =   fracgf fracpartial etapartial x   \nu_rm geostrophic  = - fracgf fracpartial etapartial y = 0  \nendaligned","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"The geostrophic solution should capture well the the behavior of the flow in the center of the domain, after small-scale disturbances propagate away.","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"u_geostrophic = zeros(grid.nx)  # -g/f ∂η/∂y = 0\nv_geostrophic = params.g / params.f * irfft(im * grid.kr .* vars.ηh, grid.nx)  #g/f ∂η/∂x\n\nplot_u = plot(grid.x/1e3, [vars.u u_geostrophic], # divide with 1e3 to convert m -> km\n                 color = [:red :purple],\n                labels = [\"u\" \"- g/f ∂η/∂y\"],\n             linewidth = [3 2],\n                 alpha = 0.7,\n                 xlims = (-Lx/2e3, Lx/2e3),       # divide with 1e3 to convert m -> km\n                 ylims = (-0.3, 0.3),\n                xlabel = \"x [km]\",\n                ylabel = \"u [m s⁻¹]\")\n\nplot_v = plot(grid.x/1e3, [vars.v v_geostrophic], # divide with 1e3 to convert m -> km\n                 color = [:green :purple],\n                labels = [\"v\" \"g/f ∂η/∂x\"],\n             linewidth = [3 2],\n                 alpha = 0.7,\n                 xlims = (-Lx/2e3, Lx/2e3),       # divide with 1e3 to convert m -> km\n                 ylims = (-0.3, 0.3),\n                xlabel = \"x [km]\",\n                ylabel = \"v [m s⁻¹]\")\n\ntitle = plot(title = \"Geostrophic balance\",\n              grid = false,\n          showaxis = false,\n            xticks = [],\n            yticks = [],\n     bottom_margin = -20Plots.px)\n\nplot(title, plot_u, plot_v,\n           layout = @layout([A{0.01h}; [B; C]]),\n             size = (600, 400))","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"","category":"page"},{"location":"generated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#FourierFlows.jl-Documentation","page":"Home","title":"FourierFlows.jl Documentation","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"FourierFlows provides a framework to write solvers for partial differential equations on periodic domains with Fourier-based pseudospectral methods that run seamlessly on CPUs and GPUs. We support 1-, 2-, and 3-dimensional domains.","category":"page"},{"location":"","page":"Home","title":"Home","text":"At the moment we have a lot of modules for solving PDEs related geophysical settings but it's easy to generalize to other PDEs.","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"An example demonstrating how to code up and solve the linear shallow water equations is found in the Examples section of the documentation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more examples of FourierFlows.jl in action, see the child packages GeophysicalFlows.jl or PassiveTracerFlows.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"info: Unicode\nOftentimes unicode symbols appear in modules for variables or parameters. For example, κ appears as the diffusivity in the Diffusion module. Unicode symbols can be entered  in the Julia REPL by typing, e.g., \\kappa followed by tab key. Read more about Unicode  symbols in the Julia Documentation.","category":"page"},{"location":"#Developers","page":"Home","title":"Developers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"FourierFlows is currently being developed by Gregory L. Wagner and  Navid C. Constantinou.","category":"page"},{"location":"#Cite","page":"Home","title":"Cite","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The code is citable via zenodo.","category":"page"},{"location":"library/public/#Public-Documentation","page":"Public","title":"Public Documentation","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Documentation for FourierFlows.jl's public interface.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"See the Internals section of the manual for internal package docs covering all submodules.","category":"page"},{"location":"library/public/#FourierFlows","page":"Public","title":"FourierFlows","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [FourierFlows]\nPrivate = false\nPages   = [\"FourierFlows.jl\"]","category":"page"},{"location":"library/public/#FourierFlows.FourierFlows","page":"Public","title":"FourierFlows.FourierFlows","text":"Main module for FourierFlows.jl – an ecosystem for solving partial differential equations  on periodic domains using Fourier-based pseudospectral methods.\"\n\nExports\n\nAB3TimeStepper\nAS\nAbstractGrid\nAbstractParams\nAbstractTimeStepper\nAbstractVars\nAnyCuArray\nAnyCuMatrix\nAnyCuVecOrMat\nAnyCuVector\nArrayType\nCPU\nCUA_NULL\nCUBLAS\nCUDA\nCUDNN\nCUFFT\nCUPTI\nCURAND\nCUSOLVER\nCUSPARSE\nCUTENSOR\nCU_NULL\nCuArray\nCuArrayPtr\nCuContext\nCuCurrentContext\nCuCurrentDevice\nCuDefaultStream\nCuDevice\nCuDeviceArray\nCuDeviceMatrix\nCuDeviceStream\nCuDeviceTexture\nCuDeviceVector\nCuDim\nCuDim3\nCuError\nCuEvent\nCuFunction\nCuGlobal\nCuIterator\nCuLink\nCuLinkImage\nCuMatrix\nCuModule\nCuModuleFile\nCuPrimaryContext\nCuPtr\nCuRef\nCuStream\nCuStreamLegacy\nCuStreamPerThread\nCuTexture\nCuTextureArray\nCuVecOrMat\nCuVector\nDenseCuArray\nDenseCuMatrix\nDenseCuVecOrMat\nDenseCuVector\nDevice\nDiagnostic\nETDRK4TimeStepper\nFULL_MASK\nFilteredAB3TimeStepper\nFilteredETDRK4TimeStepper\nFilteredForwardEulerTimeStepper\nFilteredRK4TimeStepper\nForwardEulerTimeStepper\nGPU\nMem\nNVML\nNVTX\nOneDGrid\nOutOfGPUMemoryError\nOutput\nPtrOrCuPtr\nRK4TimeStepper\nRefOrCuRef\nStridedCuArray\nStridedCuMatrix\nStridedCuVecOrMat\nStridedCuVector\nThreeDGrid\nTimeStepper\nTwoDGrid\nWMMA\nZeroDGrid\nactivate\nactive_blocks\nadd_data!\nadd_file!\n@atomic\nattribute\nattribute!\nattributes\nblockDim\nblockIdx\ncache_config\ncache_config!\ncapability\nclock\ncomplete\ncontext\ncontext!\n@createarrays\ncu\n@cuDynamicSharedMem\n@cuStaticSharedMem\n@cuassert\n@cuda\ncudacall\ncudaconvert\ncufunction\n@cuprint\n@cuprintf\n@cuprintln\n@cushow\ncxtype\ndealias!\ndevice\ndevice!\n@device_code\n@device_code_llvm\n@device_code_lowered\n@device_code_ptx\n@device_code_sass\n@device_code_typed\n@device_code_warntype\ndevice_reset!\ndeviceid\ndevices\n@devzeros\ndevzeros\ndynamic_cufunction\nelapsed\nfft\nflags\nfltype\nget\ngridDim\ngridpoints\ngroupsize\nhas_cuda\nhas_cuda_gpu\nhas_cudnn\nhas_cupti\nhas_cutensor\nhas_nvml\nhas_nvtx\nifft\nincrement!\ninnereltype\nirfft\nis_managed\nisactive\nlaunch_configuration\nldg\nlimit\nlimit!\nmalloc\nmemory_type\nname\nnanosleep\nndevices\nnextwarp\noccupancy\nprevwarp\npriority\npriority_range\nrand_logn!\nrand_poisson!\nrecord\nresize!\nrfft\nsavediagnostic\nsaveoutput\nsaveproblem\nset\nsetflags!\nshfl_down_sync\nshfl_sync\nshfl_up_sync\nshfl_xor_sync\nshmem_config\nshmem_config!\nstep_until!\nstepforward!\nsupersize\n@superzeros\nsuperzeros\nsync_grid\nsync_threads\nsync_threads_and\nsync_threads_count\nsync_threads_or\nsync_warp\nsynchronize\nthis_grid\nthreadIdx\nthreadfence\nthreadfence_block\nthreadfence_system\ntotalmem\nunsafe_cached_load\nunsafe_reset!\nupdate!\nuuid\nvote_all\nvote_any\nvote_ballot\nwarpsize\n@zeros\n\n\n\n\n\n","category":"module"},{"location":"library/public/#FourierFlows.AbstractGrid","page":"Public","title":"FourierFlows.AbstractGrid","text":"Abstract supertype for grids.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.AbstractParams","page":"Public","title":"FourierFlows.AbstractParams","text":"Abstract supertype for parameters.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.AbstractTimeStepper","page":"Public","title":"FourierFlows.AbstractTimeStepper","text":"Abstract supertype for timesteppers.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.AbstractVars","page":"Public","title":"FourierFlows.AbstractVars","text":"Abstract supertype for variables.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.CPU","page":"Public","title":"FourierFlows.CPU","text":"CPU device.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.Device","page":"Public","title":"FourierFlows.Device","text":"Abstract supertype for device.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.GPU","page":"Public","title":"FourierFlows.GPU","text":"GPU device.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#Problem","page":"Public","title":"Problem","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [FourierFlows]\nPrivate = false\nPages   = [\"problem.jl\"]","category":"page"},{"location":"library/public/#Domain","page":"Public","title":"Domain","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [FourierFlows]\nPrivate = false\nPages   = [\"domains.jl\"]","category":"page"},{"location":"library/public/#FourierFlows.OneDGrid","page":"Public","title":"FourierFlows.OneDGrid","text":"A one-dimensional grid object.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.OneDGrid-Tuple{Any,Any}","page":"Public","title":"FourierFlows.OneDGrid","text":"OneDGrid(nx, Lx; x0=-Lx/2, nthreads=Sys.CPU_THREADS, effort=FFTW.MEASURE, \n                  T=Float64, dealias=1/3, ArrayType=Array)\n\nConstructs a OneDGrid object with size Lx, resolution nx, and leftmost position x0.  FFT plans are generated for nthreads CPUs using FFTW flag effort. The float type is T  and the array types is ArrayType. The dealias keyword determines the highest  wavenubers  that are being zero-ed out by dealias() function; 1/3 is the nominal value for quadratic  nonlinearities. \n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.ThreeDGrid","page":"Public","title":"FourierFlows.ThreeDGrid","text":"A three-dimensional grid object.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.ThreeDGrid-2","page":"Public","title":"FourierFlows.ThreeDGrid","text":"ThreeDGrid(nx, Lx, ny=nx, Ly=Lx, nz=nx, Lz=Lx; x0=-Lx/2, y0=-Ly/2, z0=-Lz/2, \nnthreads=Sys.CPU_THREADS, effort=FFTW.MEASURE, T=Float64, dealias=1/3, ArrayType=Array)\n\nConstructs a TwoDGrid object with size Lx, Ly, Lz, resolution nx, ny,  nz and leftmost positions x0, y0, z0. FFT plans are generated for nthreads   CPUs using FFTW flag effort. The float type is T and the array types is ArrayType.   The dealias keyword determines the highest wavenubers that are being zero-ed  out by dealias() function; 1/3 is the nominal value for quadratic nonlinearities. \n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.TwoDGrid","page":"Public","title":"FourierFlows.TwoDGrid","text":"A two-dimensional grid object.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.TwoDGrid-2","page":"Public","title":"FourierFlows.TwoDGrid","text":"TwoDGrid(nx, Lx, ny=nx, Ly=Lx; x0=-Lx/2, y0=-Ly/2, nthreads=Sys.CPU_THREADS, \n                  effort=FFTW.MEASURE, T=Float64, dealias=1/3, ArrayType=Array)\n\nConstructs a TwoDGrid object with size Lx, Ly, resolution nx, ny, and leftmost positions x0, y0. FFT plans are generated for nthreads CPUs using FFTW flag effort. The float type is T and the array types is ArrayType.  The dealias keyword determines the highest wavenubers that are being zero-ed out by dealias() function; 1/3 is the nominal value for quadratic nonlinearities. \n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.ZeroDGrid","page":"Public","title":"FourierFlows.ZeroDGrid","text":"A placeholder grid object for 0D problems (in other words, systems of ODEs).\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.dealias!-Tuple{Any,OneDGrid}","page":"Public","title":"FourierFlows.dealias!","text":"dealias!(a, grid, kalias)\n\nDealias array a on the grid with aliased x-wavenumbers kalias.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.gridpoints-Union{Tuple{TwoDGrid{T,A,Tx,Tfft,Trfft} where Trfft where Tfft where Tx}, Tuple{A}, Tuple{T}} where A where T","page":"Public","title":"FourierFlows.gridpoints","text":"gridpoints(grid::TwoDGrid)\ngridpoints(grid::ThreeDGrid)\n\nReturns the collocation points of the grid in 2D or 3D arrays X, Y (and Z).\n\n\n\n\n\n","category":"method"},{"location":"library/public/#Utilities","page":"Public","title":"Utilities","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [FourierFlows]\nPrivate = false\nPages   = [\"utils.jl\"]","category":"page"},{"location":"library/public/#FourierFlows.ArrayType-Tuple{CPU}","page":"Public","title":"FourierFlows.ArrayType","text":"ArrayType(::Device)\nArrayType(::Device, T, dim)\n\nReturns the proper array type according to the Device chosen, i.e., Array for CPU and CuArray for GPU.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.cxtype-Union{Tuple{Type{T}}, Tuple{T}} where T<:Number","page":"Public","title":"FourierFlows.cxtype","text":"cxtype(T)\n\nReturns T when T is Complex, or Complex{T} when T is Real.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.devzeros-Tuple{Any,Any,Any}","page":"Public","title":"FourierFlows.devzeros","text":"devzeros(dev, T, dims)\n\nReturns an array like A of type T, but full of zeros.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.fltype-Union{Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Public","title":"FourierFlows.fltype","text":"fltype(T)\n\nReturns T when T<:AbstractFloat or Tf when T<:Complex{Tf}.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.innereltype-Tuple{Any}","page":"Public","title":"FourierFlows.innereltype","text":"innereltype(x)\n\nRecursively determine the 'innermost' type in by the collection x (which may be, for example, a collection of a collection).\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.superzeros-Tuple{Any,AbstractArray}","page":"Public","title":"FourierFlows.superzeros","text":"superzeros(T, A)\n\nReturns an array like A, but full of zeros. If innereltype(A) can be promoted to T, then the innermost elements of the array will have type T.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.@devzeros-Tuple{Any,Any,Any,Vararg{Any,N} where N}","page":"Public","title":"FourierFlows.@devzeros","text":"@devzeros dev T dims a b c...\n\nCreate arrays of all zeros with element type T, size dims, and global names a, b, c (for example) on device dev.\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#FourierFlows.@superzeros-Tuple{Any,Any,Vararg{Any,N} where N}","page":"Public","title":"FourierFlows.@superzeros","text":"@superzeros T a b c d...\n@superzeros T dims b c d...\n\nGenerate arrays b, c, d... with the super-dimensions of a and innereltype T.\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#FourierFlows.@zeros-Tuple{Any,Any,Vararg{Any,N} where N}","page":"Public","title":"FourierFlows.@zeros","text":"@zeros T dims a b c...\n\nCreate arrays of all zeros with element type T, size dims, and global names a, b, c (for example). An arbitrary number of arrays may be created.\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#Diagnostics","page":"Public","title":"Diagnostics","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [FourierFlows]\nPrivate = false\nPages   = [\"diagnostics.jl\"]","category":"page"},{"location":"library/public/#FourierFlows.Diagnostic","page":"Public","title":"FourierFlows.Diagnostic","text":"Diagnostic(calc, prob; freq=1, nsteps=100, N=floor(Int, (nsteps+1)/freq))\n\nConstruct a diagnostic which stores the result of calc(prob) with frequency freq\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.increment!-Tuple{Any}","page":"Public","title":"FourierFlows.increment!","text":"increment!(diag)\n\nIncrement the Diagnostic diag, or an array of Diagnostics diags.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.update!-Tuple{Any,Any}","page":"Public","title":"FourierFlows.update!","text":"update!(diag)\n\nUpdate diag.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#Output","page":"Public","title":"Output","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [FourierFlows]\nPrivate = false\nPages   = [\"output.jl\"]","category":"page"},{"location":"library/public/#FourierFlows.Output","page":"Public","title":"FourierFlows.Output","text":"Output(prob, filename, fieldtuples...)\n\nDefine output for prob with fields and functions that calculate the output in the list of tuples fieldtuples = (fldname, func)....\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.savediagnostic-Tuple{Any,Any,Any}","page":"Public","title":"FourierFlows.savediagnostic","text":"savediagnostic(diag, diagname)\n\nSave diagnostics in diag to file, labeled by diagname.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.saveoutput-Tuple{Any}","page":"Public","title":"FourierFlows.saveoutput","text":"saveoutput(out)\n\nSave the fields in out.fields to out.path.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.saveproblem-Tuple{Any,Any}","page":"Public","title":"FourierFlows.saveproblem","text":"saveproblem(prob, filename)\n\nSave certain aspects of a problem.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#Timesteppers","page":"Public","title":"Timesteppers","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [FourierFlows]\nPrivate = false\nPages   = [\"timesteppers.jl\"]","category":"page"},{"location":"library/public/#FourierFlows.AB3TimeStepper","page":"Public","title":"FourierFlows.AB3TimeStepper","text":"AB3TimeStepper{T} <: AbstractTimeStepper{T}\n\nType for 3rd order Adams-Bashforth time-stepper.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.AB3TimeStepper-2","page":"Public","title":"FourierFlows.AB3TimeStepper","text":"FilteredAB3TimeStepper(equation, dev; filterkwargs...)\n\nConstruct a 3rd order Adams-Bashforth time stepper.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.ETDRK4TimeStepper","page":"Public","title":"FourierFlows.ETDRK4TimeStepper","text":"ETDRK4TimeStepper{T,TL} <: AbstractTimeStepper{T}\n\nType for 4th-order exponential-time-differencing Runge-Kutta time stepper.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.ETDRK4TimeStepper-2","page":"Public","title":"FourierFlows.ETDRK4TimeStepper","text":"ETDRK4TimeStepper(eq::Equation, dt, dev::Device=CPU())\n\nConstruct a 4th-order exponential-time-differencing Runge-Kutta time stepper.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.FilteredAB3TimeStepper","page":"Public","title":"FourierFlows.FilteredAB3TimeStepper","text":"FilteredAB3TimeStepper{T} <: AbstractTimeStepper{T}\n\nType for 3rd order Adams-Bashforth time-stepper with spectral filtering.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.FilteredAB3TimeStepper-2","page":"Public","title":"FourierFlows.FilteredAB3TimeStepper","text":"FilteredAB3TimeStepper(equation, dev; filterkwargs...)\n\nConstruct a 3rd order Adams-Bashforth time stepper with spectral filtering.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.FilteredETDRK4TimeStepper","page":"Public","title":"FourierFlows.FilteredETDRK4TimeStepper","text":"FilteredETDRK4TimeStepper{T,TL,Tf} <: AbstractTimeStepper{T}\n\nType for 4th-order exponential-time-differencing Runge-Kutta time stepper with spectral filtering.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.FilteredETDRK4TimeStepper-2","page":"Public","title":"FourierFlows.FilteredETDRK4TimeStepper","text":"FilteredETDRK4TimeStepper(equation, dt; filterkwargs...)\n\nConstruct a 4th-order exponential-time-differencing Runge-Kutta time stepper with spectral filtering.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.FilteredForwardEulerTimeStepper","page":"Public","title":"FourierFlows.FilteredForwardEulerTimeStepper","text":"FilteredForwardEulerTimeStepper(eq, dev; filterkwargs...)\n\nType for Forward Euler timestepper with spectral filtering.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.FilteredForwardEulerTimeStepper-2","page":"Public","title":"FourierFlows.FilteredForwardEulerTimeStepper","text":"FilteredForwardEulerTimeStepper(eq, dev; filterkwargs...)\n\nConstruct a forward Euler timestepper with spectral filtering.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.FilteredRK4TimeStepper","page":"Public","title":"FourierFlows.FilteredRK4TimeStepper","text":"FilteredRK4TimeStepper{T,Tf} <: AbstractTimeStepper{T}\n\nType for 4th-order Runge-Kutta time stepper with spectral filtering for the equation eq.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.FilteredRK4TimeStepper-2","page":"Public","title":"FourierFlows.FilteredRK4TimeStepper","text":"FilteredRK4TimeStepper(eq::Equation, dev::Device=CPU(); filterkwargs...)\n\nConstruct a 4th-order Runge-Kutta time stepper with spectral filtering for the equation eq.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.ForwardEulerTimeStepper","page":"Public","title":"FourierFlows.ForwardEulerTimeStepper","text":"ForwardEulerTimeStepper{T} <: AbstractTimeStepper{T}\n\nType for Forward Euler timestepper.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.ForwardEulerTimeStepper-2","page":"Public","title":"FourierFlows.ForwardEulerTimeStepper","text":"ForwardEulerTimeStepper(eq::Equation, dev::Device=CPU())\n\nConstruct a Forward Euler timestepper.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.RK4TimeStepper","page":"Public","title":"FourierFlows.RK4TimeStepper","text":"RK4TimeStepper{T} <: AbstractTimeStepper{T}\n\nType for 4th-order Runge-Kutta time stepper for the equation eq.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.RK4TimeStepper-2","page":"Public","title":"FourierFlows.RK4TimeStepper","text":"RK4TimeStepper(eq::Equation, dev::Device=CPU())\n\nConstruct a 4th-order Runge-Kutta time stepper for the equation eq.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.TimeStepper","page":"Public","title":"FourierFlows.TimeStepper","text":"TimeStepper(stepper, equation, dt=nothing, dev=CPU(); kw...)\n\nInstantiate the Timestepper for equation with timestep dt and on the device. The kw are passed to the timestepper constructor.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#FourierFlows.step_until!-Tuple{Any,Any}","page":"Public","title":"FourierFlows.step_until!","text":"step_until!(prob, stop_time)\n\nStep forward prob until stop_time. Cannot be used with ETDRK4 time steppers.\n\nSee also: stepforward!\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.stepforward!-Tuple{FourierFlows.Problem,Any,Int64}","page":"Public","title":"FourierFlows.stepforward!","text":"stepforward!(prob::Problem, diags, nsteps::Int)\n\nStep forward prob for nsteps, incrementing diags along the way. diags may be a  single Diagnostic or a Vector of Diagnostics.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.stepforward!-Tuple{FourierFlows.Problem,Int64}","page":"Public","title":"FourierFlows.stepforward!","text":"stepforward!(prob, nsteps::Int)\n\nStep forward prob for nsteps.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.stepforward!-Tuple{FourierFlows.Problem}","page":"Public","title":"FourierFlows.stepforward!","text":"stepforward!(prob)\n\nStep forward prob one time step.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#Diffusion-Testbed-Module","page":"Public","title":"Diffusion Testbed Module","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [FourierFlows.Diffusion]\nPrivate = false\nPages   = [\"diffusion.jl\"]","category":"page"},{"location":"library/public/#FourierFlows.Diffusion.Problem-Tuple{}","page":"Public","title":"FourierFlows.Diffusion.Problem","text":"Problem(; parameters...)\n\nConstruct a constant diffusivity problem.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.Diffusion.set_c!-Tuple{Any,Any}","page":"Public","title":"FourierFlows.Diffusion.set_c!","text":"set_c!(prob, c)\n\nSet the solution as the transform of c and update vars.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.Diffusion.updatevars!-Tuple{Any,Any,Any}","page":"Public","title":"FourierFlows.Diffusion.updatevars!","text":"updatevars!(vars, grid, sol)\n\nUpdate the variables in vars on the grid with the solution in sol.\n\n\n\n\n\n","category":"method"}]
}
