var documenterSearchIndex = {"docs":
[{"location":"contributing/#Contributors-Guide","page":"Contributor's guide","title":"Contributors Guide","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"This is a short guide for potential FourierFlows.jl contributors.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Please feel free to ask us questions and chat, either by raising an issue or starting a discussion.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"We follow the ColPrac guide for collaborative practices.  New contributors should make sure to read that guide.","category":"page"},{"location":"contributing/#What-can-I-do?","page":"Contributor's guide","title":"What can I do?","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Tackle an existing issue.\nImprove documentation, docstrings, or comments if you found something is hard to use.\nImplement a new feature (e.g., a new diagnostic into a module).","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"If you're interested in working on something, let us know by commenting on an existing issue  or by opening a new issue. This is to make sure no one else is working on the same issue and  so we can help and guide you in case there is anything you need to know beforehand.","category":"page"},{"location":"contributing/#Ground-Rules","page":"Contributor's guide","title":"Ground Rules","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Each pull request should consist of a logical collection of changes. You can include multiple bug fixes in a single pull request, but they should be related. For unrelated changes, please submit multiple pull requests.\nDo not commit changes to files that are irrelevant to your feature or bugfix (e.g., .gitignore).\nBe willing to accept criticism and work on improving your code; we don't want to break other users' code, so care must be taken not to introduce bugs. We discuss pull requests and keep working on them until we believe we've done a good job.\nBe aware that the pull request review process is not immediate, and is generally proportional to the size of the pull request.","category":"page"},{"location":"contributing/#Reporting-a-bug","page":"Contributor's guide","title":"Reporting a bug","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"The easiest way to get involved is to report issues you encounter when using FourierFlows.jl  or by requesting something you think is missing.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Head over to the issues page.\nSearch to see if your issue already exists or has even been solved previously.\nIf you indeed have a new issue or request, click the \"New Issue\" button.\nPlease be as specific as possible. Include the version of the code you were using, as well as what operating system you are running. The output of Julia's versioninfo() and ] status is helpful to include. If possible, include complete, minimal example code that reproduces the problem.","category":"page"},{"location":"contributing/#Setting-up-your-development-environment","page":"Contributor's guide","title":"Setting up your development environment","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Install Julia on your system.\nInstall git on your system if it is not already there (install XCode command line tools on a Mac or git bash on Windows).\nLogin to your GitHub account and make a fork of the FourierFlows.jl repository by clicking the \"Fork\" button.\nClone your fork of the FourierFlows.jl repository (in terminal on Mac/Linux or git shell/ GUI on Windows) in the location you'd like to keep it.\ngit clone https://github.com/your-user-name/FourierFlows.jl.git\nNavigate to that folder in the terminal or in Anaconda Prompt if you're on Windows.\nConnect your repository to the upstream (main project).\ngit remote add FourierFlows https://github.com/FourierFlows/FourierFlows.jl.git\nCreate the development environment by opening Julia via julia --project then typing in ] instantiate. This will install all the dependencies in the Project.toml file.\nYou can test to make sure FourierFlows.jl works by typing in ] test. This will run all the tests (this can take a while). In an ideal world you should run the tests on a machine with a GPU capability but if that's not a possibility that is available to you then don't  worry ‚Äì simply comment in a PR that you didn't test on GPU.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Your development environment is now ready!","category":"page"},{"location":"contributing/#Pull-Requests","page":"Contributor's guide","title":"Pull Requests","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Changes and contributions should be made via GitHub pull requests against the master branch.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"When you're done making changes, commit the changes you made. Chris Beams has written  a guide on how to write good commit messages.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"When you think your changes are ready to be merged into the main repository, push to your fork and submit a pull request.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Working on your first Pull Request? You can learn how from this free video series How to Contribute to an Open Source Project on GitHub, Aaron Meurer's tutorial on the git workflow,  or the guide ‚ÄúHow to Contribute to Open Source\".","category":"page"},{"location":"contributing/#Documentation","page":"Contributor's guide","title":"Documentation","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"All PRs that introduce new features or new modules should be accompanied with appropriate  docstrings and documentation. Writing documentation strings is really important to make sure  others use your functionality properly. Didn't write new functions? That's fine, but be sure  that the documentation for the code you touched is still in great shape. It is not uncommon  to find some strange wording or clarification that you can take care of while you are here.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"We encourage using unicode characters  when writing docstrings, e.g., use Œ± instead of \\alpha. This makes the rendering of the  docstrings in the Documentation and in the Julia REPL's help?> mode as similar as possible.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"You can preview how the Documentation will look like after merging by building the documentation  locally. To do that, from the main directory of your local repository call","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"julia --project=docs/ -e 'using Pkg; Pkg.develop(PackageSpec(path=pwd())); Pkg.instantiate()'\njulia --project=docs/ docs/make.jl","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"and then open docs/build/index.html in your favorite browser.","category":"page"},{"location":"contributing/#Credits","page":"Contributor's guide","title":"Credits","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"This contributor's guide is heavily based on the MetPy contributor's guide  and on its \"cover\" made by Oceananigans.jl.","category":"page"},{"location":"basics/#Code-Basics","page":"Code Basics","title":"Code Basics","text":"","category":"section"},{"location":"basics/","page":"Code Basics","title":"Code Basics","text":"The code solves partial differential equations of the form","category":"page"},{"location":"basics/","page":"Code Basics","title":"Code Basics","text":" partial_t u = Lu + N(u)  ","category":"page"},{"location":"basics/","page":"Code Basics","title":"Code Basics","text":"using Fourier transforms on periodic domains. Above, u(bmx t) is the state variable.  On the right-hand-side, term L u is the 'linear' part of the equation. The term  N(u) is, in general, a 'nonlinear' part.","category":"page"},{"location":"basics/","page":"Code Basics","title":"Code Basics","text":"In FourierFlows.jl, L u is specified by the various modules by prescribing the linear operator L as an array of the same dimension as u. The nonlinear term  N(u) is specified via a function that takes u as its argument.","category":"page"},{"location":"basics/","page":"Code Basics","title":"Code Basics","text":"Boundary conditions in all spatial dimensions are periodic. That allows us to expand all  variables using a Fourier decomposition. For example, if u depends only in one spatial  dimension, x, defined over the domain x in 0 L_x, then:","category":"page"},{"location":"basics/","page":"Code Basics","title":"Code Basics","text":"u(x t) = sum_k_x hatu(k_x t)  e^i k_x x  ","category":"page"},{"location":"basics/","page":"Code Basics","title":"Code Basics","text":"where wavenumbers k_x take the values tfrac2piL_x0pm 1pm 2dots. When we  further consider that x takes discrete values over 0 L_x, e.g., x_j, j = 0 1 dots n_x, then only n_x wavenumbers are independent. By denoting u_j(t) equiv u(x_j t)  and hatu_k(t) equiv hatu(tfrac2piL_x k t) with k an integer, then the  Fourier sum above truncates to:","category":"page"},{"location":"basics/","page":"Code Basics","title":"Code Basics","text":"u_j(t) = sum_k=-n_x2^n_x2-1 hatu_k(t)e^2pi i k x_j  L_x  ","category":"page"},{"location":"basics/","page":"Code Basics","title":"Code Basics","text":"(We assumed here that n_x is even.)","category":"page"},{"location":"basics/","page":"Code Basics","title":"Code Basics","text":"Applying the Fourier transform as above, the partial differential equation transforms to:","category":"page"},{"location":"basics/","page":"Code Basics","title":"Code Basics","text":" partial_t hatu = hatL hatu + widehat N(u)   ","category":"page"},{"location":"basics/","page":"Code Basics","title":"Code Basics","text":"where hatL above denotes the linear operator in Fourier space.","category":"page"},{"location":"basics/","page":"Code Basics","title":"Code Basics","text":"Equations are oftentimes time-stepped forward in Fourier space. Doing so, hatu_k(t)  becomes now our state variable, i.e., the array with all Fourier coefficients of the solution  u. Although time-stepping in Fourier space is by no means a restriction of the code, it  usually enhances performance because it requires less transformations back and forth from  physical to Fourier space and vice versa.","category":"page"},{"location":"aliasing/#Aliasing","page":"Aliasing","title":"Aliasing","text":"","category":"section"},{"location":"aliasing/","page":"Aliasing","title":"Aliasing","text":"using FourierFlows\nusing Plots\nPlots.default(lw=3)","category":"page"},{"location":"aliasing/","page":"Aliasing","title":"Aliasing","text":"In pseudospectral methods, when computing nonlinear terms then aliasing errors come into play.  These aliasing errors originate from the discrete nature of the grid and, specifically, the  restriction that a grid discretized with n_x points can only resolve up to n_x  wavenumbers in Fourier space. ","category":"page"},{"location":"aliasing/","page":"Aliasing","title":"Aliasing","text":"Consider a grid with a total of n_x points. Both harmonics e^2pi i k x  L_x and  e^2pi i (k+n_x) x  L_x, with k an integer, are indistinguishable when evaluated on the discrete grid-points of this grid. When we compute nonlinear terms in physical space (products of various fields), we may end up with terms that project on harmonics with wavenumber beyond the maximum wavenumber that can be resolved by our grid. In that case, those wavenumbers  will be erroneously projected onto some lower wavenumber modes that fit our domain.","category":"page"},{"location":"aliasing/","page":"Aliasing","title":"Aliasing","text":"Take, for example, functions cos(4x) and cos(6x) and let's see how they are represented  on a grid x in -œÄ œÄ) with n_x = 10 grid points.","category":"page"},{"location":"aliasing/","page":"Aliasing","title":"Aliasing","text":"using FourierFlows, Plots\n\nnx, Lx = 10, 2œÄ\ngrid = OneDGrid(nx, Lx)\nx = grid.x\n\nf1(x) = cos(4x)\nf2(x) = cos(6x)\n\np = plot(x, f1.(x), lw=0, marker=:circle, c=:red, ms=8, ylims=(-1.6, 1.6), label=\"cos(4x)\")\nplot!(p, f1, lw=3, alpha=0.2, c=:red, xlims=(-Lx/2, Lx/2), label=\"\")\nplot!(p, x, f2.(x), lw=0, marker=:star5, ms=8.5, color=:blue, alpha=0.8, label=\"cos(6x)\")\nplot!(p, f2, lw=3, alpha=0.2, c=:blue, xlims=(-Lx/2, Lx/2), label=\"\")\n\nplot(p, xlabel=\"x\", xlims=(-3.3, 3.3))\n\nsavefig(\"assets/plot4.svg\"); nothing # hide","category":"page"},{"location":"aliasing/","page":"Aliasing","title":"Aliasing","text":"(Image: )","category":"page"},{"location":"aliasing/","page":"Aliasing","title":"Aliasing","text":"The take home message is that on this particular grid we cannot distinguish harmonics with  wavenumbers 4 and 6. An attempt to represent harmonics with wavenumber 6 on this grid leads to  aliasing errors. For example, say that we are solving an equation and at some point we compute  the product cos(2x) cos(4x). The result should be frac12 cos(2x) + frac12 cos(6x),  but on this grid cos(6x) is indistinguishable from cos(4x) and, therefore, what we compute will be indistinguishable from frac12 cos(2x) + frac12 cos(4x)!","category":"page"},{"location":"aliasing/","page":"Aliasing","title":"Aliasing","text":"To avoid aliasing errors we either (i) discard some of the wavenumber components in Fourier  space from our fields before we transform to physical space, or (ii) pad our fields with Fourier  components with zero power that correspond to higher wavenumbers than those resolved by the grid  before transforming to physical space. This way, the aliasing errors, which will involve the  higher wavenumbers, will be either (i) zero-ed out or (ii) only come about for wavenumbers  beyond what our grid can resolve anyway. In FourierFlows.jl, the former dealiasing scheme is  implemented.","category":"page"},{"location":"aliasing/","page":"Aliasing","title":"Aliasing","text":"info: De-aliasing scheme\nFourierFlows.jl currently implements dealiasing by zeroing out the highest-aliased_fraction  wavenumber components on a grid.","category":"page"},{"location":"aliasing/","page":"Aliasing","title":"Aliasing","text":"The number of wavenumber components that we need to zero-out to be sure the no aliasing errors  infiltrate our solution depends on the order of the nonlinearities. For example, for quadratic  nonlinearities, one expects that we need to discard the highest-1/2 of the wavenumber components.  This way, when computing the product of two fields we won't have anything that projects onto harmonics with wavenumbers beyond those that our grid is able to resolve and, therefore, no  aliasing errors.","category":"page"},{"location":"aliasing/","page":"Aliasing","title":"Aliasing","text":"The above-mentioned 1/2-rule for dealiasing for quadratic nonlinearities is, however, not the  most efficient. Orszag (1972) pointed out that for quadratic nonlirearities, simply only discarding  the highest-1/3 of wavenumber components is enough to save us from aliasing errors. To be fair,  with Orszag's so-called 2/3-rule for dealiasing, still some aliasing errors occur, but those  errors only occur to the higher-1/3 wavenumber components that will be zero-ed out next time  we dealias our solution anyway.","category":"page"},{"location":"aliasing/","page":"Aliasing","title":"Aliasing","text":"When constructing a grid we can specify the aliased_fraction parameter. By default, this is  set to 13, appropriate for quadratic nonlinearities. Then dealias!(fh, grid) will zero-out  the highest-aliased_fraction wavenumber components of fh. ","category":"page"},{"location":"aliasing/","page":"Aliasing","title":"Aliasing","text":"FourierFlows.dealias!","category":"page"},{"location":"aliasing/#FourierFlows.dealias!","page":"Aliasing","title":"FourierFlows.dealias!","text":"dealias!(fh, grid)\n\nDealias array fh on the grid based on the grids's aliased_factor.\n\n\n\n\n\n","category":"function"},{"location":"aliasing/","page":"Aliasing","title":"Aliasing","text":"If we construct a grid with aliased_fraction=0, e.g.,","category":"page"},{"location":"aliasing/","page":"Aliasing","title":"Aliasing","text":"grid_nodealias = OneDGrid(nx, Lx; aliased_fraction=0)","category":"page"},{"location":"aliasing/","page":"Aliasing","title":"Aliasing","text":"then dealias!(fh, grid_nodealias) will have no effect whatsoever on fh.","category":"page"},{"location":"output/#Output","page":"Output","title":"Output","text":"","category":"section"},{"location":"output/","page":"Output","title":"Output","text":"To save output we use Output. Let's see how we can use the example developed in Problem and Diagnostics sections to demonstrate how we can save some output to disk and then load it.","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"DocTestSetup = quote\n    using FourierFlows\n    using LinearAlgebra: mul!, ldiv!\n    nx, Lx = 32, 2.0\n    grid = OneDGrid(nx, Lx)\n    struct Params <: AbstractParams\n    Œ± :: Float64\n    end\n    params = Params(0.1)\n    struct Vars <: AbstractVars\n        u :: Array{Float64,1}\n    uh :: Array{Complex{Float64}, 1}\n    end\n    vars = Vars(zeros(Float64, (grid.nx,)), zeros(Complex{Float64}, (grid.nkr,)))\n    L = - params.Œ± * ones(grid.nkr)\n    function calcN!(N, sol, t, clock, vars, params, grid)\n    @. N = 0\n    return nothing\n    end\n    equation = FourierFlows.Equation(L, calcN!, grid)\n    stepper, dt = \"ForwardEuler\", 0.02\n    prob = FourierFlows.Problem(equation, stepper, dt, grid, vars, params)\n    u0 = @. cos(œÄ * grid.x)\n    mul!(prob.sol, grid.rfftplan, u0)\n    function energy(prob)\n        ldiv!(prob.vars.u, grid.rfftplan, prob.sol)\n        return sum(prob.vars.u.^2) * prob.grid.dx\n    end\n    E = Diagnostic(energy, prob, freq=2, nsteps=200)\n    filepath = \".\"\n    filename = joinpath(filepath, \"simplestpde.jld2\")\n    get_uh(prob) = prob.sol\nend","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"using FourierFlows, Plots\n\nusing LinearAlgebra: mul!, ldiv!\n\nPlots.default(lw=3)\n\nnx, Lx = 32, 2.0\ngrid = OneDGrid(nx, Lx)\n\nstruct Params <: AbstractParams\n  Œ± :: Float64\nend\n\nparams = Params(0.1)\n\nstruct Vars <: AbstractVars\n    u :: Array{Float64,1}\n   uh :: Array{Complex{Float64}, 1}\nend\n\nvars = Vars(zeros(Float64, (grid.nx,)), zeros(Complex{Float64}, (grid.nkr,)))\n\nL = - params.Œ± * ones(grid.nkr)\n\nfunction calcN!(N, sol, t, clock, vars, params, grid)\n  @. N = 0\n  \n  return nothing\nend\n\nequation = FourierFlows.Equation(L, calcN!, grid)\n\nstepper, dt = \"ForwardEuler\", 0.02\n\nprob = FourierFlows.Problem(equation, stepper, dt, grid, vars, params)\n\nu0 = @. cos(œÄ * grid.x)\n\nmul!(prob.sol, grid.rfftplan, u0)\n\nfunction energy(prob)\n    ldiv!(prob.vars.u, grid.rfftplan, prob.sol)\n    return sum(prob.vars.u.^2) * prob.grid.dx\nend\n\nE = Diagnostic(energy, prob, freq=2, nsteps=200)","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"After we have created the problem (prob) and the energy diagnostic (E), we can construct an Output. We first choose where we'd like to output the .jld2 file(s):","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"filepath = \".\"\nfilename = joinpath(filepath, \"simplestpde.jld2\")","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"and the construct the Output. To do so, we provide tuples of fields that we want to output and a function what takes prob as its argument and returns the corresponding value of that field. For this example, let's save the energy E and the state vector sol.","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"get_uh(prob) = prob.sol\n\nout = Output(prob, filename, (:uh, get_uh), (:E, energy))","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"get_uh(prob) = prob.sol #hide\n\nout = Output(prob, filename, (:uh, get_uh), (:E, energy)) #hide","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"Note that we haven't saved anything to disk yet!","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"By calling saveproblem","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"saveproblem(out)","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"we write all certain aspects of the problem on the .jld2 file. For example, doing so saves the grid parameters (Lx, nx, ...), everything in prob.params, the the linear operator and its attributes from prob.eqn, and the time-step (prob.clock.dt). All these are very useful in case we'd like to re-create the problem.","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"Let's open the file and have a quick look what's been written there.","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"using JLD2\nfile = jldopen(out.path)","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"Accessing the saved values is done using usual HDF5 way, e.g.,","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"file[\"grid/nx\"]","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"Let's now close the file and move on with our demonstration.","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"close(file)","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"Now we can start saving our output fields. We do so via saveoutput, which will go through the list of fields we provided to Output, call the functions that compute the fields, and write their results on disk.","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"saveoutput(out)","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"The output fields are saved under \"snapshots\" group, e.g.,","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"file = jldopen(out.path)\nfile[\"snapshots\"]","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"Let's close the file again.","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"close(file)","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"We can now time-step the problem forward and every now and then write the output files on disk.","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"for _ in 1:40\n    stepforward!(prob, E, 5)\n    saveoutput(out)\nend","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"All right! Now we have simulated 200 time-steps saving output every 5 time-steps.","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"Let's see now how we can load the output we saved in the .jld2 file and visualize it.","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"We load the .jld2 file and extract the saved iterations.","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"file = jldopen(out.path)\n\niterations = parse.(Int, keys(file[\"snapshots/t\"]))","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"Then we can construct a vector with all saved times and all saved values for energy.","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"times = [file[\"snapshots/t/$iteration\"] for iteration in iterations]\n\nenergies = [file[\"snapshots/E/$iteration\"] for iteration in iterations]\n\nnothing #hide","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"and plot:","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"using Plots\n\nplot(times, energies,\n      label = \"energy\",\n     xlabel = \"t\")\n\nsavefig(\"assets/plot7.svg\"); nothing # hide","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"(Image: )","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"Lastly, let's load the saved uh fields, process them (get u by convert to physical space), and animate them.","category":"page"},{"location":"output/","page":"Output","title":"Output","text":"using Printf\n\nnx = file[\"grid/nx\"]\n x = file[\"grid/x\"]\n\nanim = @animate for (i, iteration) in enumerate(iterations)\n    uh = file[\"snapshots/uh/$iteration\"]\n    u = irfft(uh, nx)\n\n    plot(x, u,\n         marker = :circle,\n          label = :none,\n         xlabel = \"x\",\n          ylims = (-1.05, 1.05),\n          title = @sprintf(\"u(x, t=%1.2f)\", times[i]))\nend\n\nmp4(anim, \"animation.mp4\", fps = 24) # hide","category":"page"},{"location":"installation_instructions/#Installation-instructions","page":"Installation Instructions","title":"Installation instructions","text":"","category":"section"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"You can install the latest version of FourierFlows.jl via the built-in package manager  (accessed by pressing ] in the Julia REPL command prompt) to add the package and also to  instantiate/build all the required dependencies","category":"page"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"julia>]\n(v1.6) pkg> add FourierFlows\n(v1.6) pkg> instantiate","category":"page"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"We recommend installing FourierFlows.jl with the built-in Julia package manager, because  this installs a stable, tagged release. Later on, you can update FourierFlows.jl to the  latest tagged release again via the package manager by typing","category":"page"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"(v1.6) pkg> update FourierFlows","category":"page"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"Note that some releases might induce breaking changes to certain modules. If after anything  happens or your code stops working, please open an issue  or start a discussion. We're  more than happy to help with getting your simulations up and running.","category":"page"},{"location":"installation_instructions/","page":"Installation Instructions","title":"Installation Instructions","text":"warn: Use Julia 1.6 or newer\nThe latest FourierFlows.jl requires at least Julia v1.6 (the current long-term-release). Installing FourierFlows with an older version of Julia will install an older version  of FourierFlows.jl (the latest version compatible with your version of Julia).Last version that works with Julia v1.5 is FourierFlows.jl v0.7.2.","category":"page"},{"location":"diagnostics/#diagnostics_docs","page":"Diagnostics","title":"Diagnostics","text":"","category":"section"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"We can add diagnostics to a FourierFlows's problem using Diagnostic functionality.","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"DocTestSetup = quote\n    using FourierFlows\n    using LinearAlgebra: mul!, ldiv!\n    nx, Lx = 32, 2.0\n    grid = OneDGrid(nx, Lx)\n    struct Params <: AbstractParams\n    Œ± :: Float64\n    end\n    params = Params(0.1)\n    struct Vars <: AbstractVars\n        u :: Array{Float64,1}\n    uh :: Array{Complex{Float64}, 1}\n    end\n    vars = Vars(zeros(Float64, (grid.nx,)), zeros(Complex{Float64}, (grid.nkr,)))\n    L = - params.Œ± * ones(grid.nkr)\n    function calcN!(N, sol, t, clock, vars, params, grid)\n    @. N = 0\n    return nothing\n    end\n    equation = FourierFlows.Equation(L, calcN!, grid)\n    stepper, dt = \"ForwardEuler\", 0.02\n    prob = FourierFlows.Problem(equation, stepper, dt, grid, vars, params)\n    u0 = @. cos(œÄ * grid.x)\n    mul!(prob.sol, grid.rfftplan, u0)\n    function energy(prob)\n        ldiv!(prob.vars.u, grid.rfftplan, prob.sol)\n        return sum(prob.vars.u.^2) * prob.grid.dx\n    end\nend","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"using FourierFlows, Plots\n\nusing LinearAlgebra: mul!\n\nPlots.default(lw=3)\n\nnx, Lx = 32, 2.0\ngrid = OneDGrid(nx, Lx)\n\nstruct Params <: AbstractParams\n  Œ± :: Float64\nend\n\nparams = Params(0.1)\n\nstruct Vars <: AbstractVars\n    u :: Array{Float64,1}\n   uh :: Array{Complex{Float64}, 1}\nend\n\nvars = Vars(zeros(Float64, (grid.nx,)), zeros(Complex{Float64}, (grid.nkr,)))\n\nL = - params.Œ± * ones(grid.nkr)\n\nfunction calcN!(N, sol, t, clock, vars, params, grid)\n  @. N = 0\n  \n  return nothing\nend\n\nequation = FourierFlows.Equation(L, calcN!, grid)\n\nstepper, dt = \"ForwardEuler\", 0.02\n\nprob = FourierFlows.Problem(equation, stepper, dt, grid, vars, params)\n\nu0 = @. cos(œÄ * grid.x)\n\nmul!(prob.sol, grid.rfftplan, u0)","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"To demonstrate how we add diagnostics to a PDE problem, let's try to add one to the simple PDE problem we constructed in the Problem section. For example, say we'd like to add a diagnostic we refer to as the \"energy\" and which we define to be:","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"E = int u^2  mathrmd x ","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"After we have constructed the problem (prob) (see Problem section), we then create a function that takes prob as its argument returns the diagnostic:","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"using LinearAlgebra: ldiv!\n\nfunction energy(prob)\n    ldiv!(prob.vars.u, grid.rfftplan, prob.sol)\n    return sum(prob.vars.u.^2) * prob.grid.dx\nend\n\nnothing #hide","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"and then we create a Diagnostic using the Diagnostic constructor. Say we want to save energy every 2 time-steps, then:","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"E = Diagnostic(energy, prob, freq=2, nsteps=200)","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"E = Diagnostic(energy, prob, freq=2, nsteps=200) #hide","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"Now, when we step forward the problem we provide the diagnostic as the second positional  argument in stepforward!:","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"stepforward!(prob, E, 200)","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"Doing so, the diagnostic is computed and saved at the appropriate frequency (prescribed by E.freq).","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"info: Multiple diagnostics\nIf we want to include multiple diagnostics we can gather all of them in an array, e.g.,diag1 = Diagnostic(foo, prob)\ndiag2 = Diagnostic(bar, prob)\n\nstepforward!(prob, [diag1, diag2], 1)","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"The times that the diagnostic was saved are gathered in E.t. Thus, we can easily plot the energy time-series, e.g., ","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"using Plots\n\nplot(E.t, E.data,\n      label = \"energy\",\n     xlabel = \"t\")\n\nsavefig(\"assets/plot6.svg\"); nothing # hide","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"(Image: )","category":"page"},{"location":"library/outline/#Library-Outline","page":"Contents","title":"Library Outline","text":"","category":"section"},{"location":"library/outline/","page":"Contents","title":"Contents","text":"Pages = [\"public.md\", \"internals.md\", \"function_index.md\"]","category":"page"},{"location":"library/internals/#Private-types-and-functions","page":"Private","title":"Private types and functions","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Documentation for FourierFlows.jl's internal interface.","category":"page"},{"location":"library/internals/#FourierFlows","page":"Private","title":"FourierFlows","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [FourierFlows]\nPublic  = false\nPages   = [\"FourierFlows.jl\"]","category":"page"},{"location":"library/internals/#FourierFlows.AbstractDiagnostic","page":"Private","title":"FourierFlows.AbstractDiagnostic","text":"Abstract supertype for diagnostics.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#Problem","page":"Private","title":"Problem","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [FourierFlows]\nPublic  = false\nPages   = [\"problem.jl\"]","category":"page"},{"location":"library/internals/#FourierFlows.Clock","page":"Private","title":"FourierFlows.Clock","text":"mutable struct Clock{T<:AbstractFloat}\n\nRepresents the clock of a problem.\n\ndt::AbstractFloat\nthe time-step\nt::AbstractFloat\nthe time\nstep::Int64\nthe step number\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#FourierFlows.EmptyParams","page":"Private","title":"FourierFlows.EmptyParams","text":"EmptyParams <: AbstractParams\n\nA placeholder struct for parameters.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#FourierFlows.EmptyVars","page":"Private","title":"FourierFlows.EmptyVars","text":"EmptyVars <: AbstractVars\n\nA placeholder struct for variables.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#FourierFlows.Equation","page":"Private","title":"FourierFlows.Equation","text":"struct Equation{T, TL, G<:AbstractFloat}\n\nThe equation to be solved ‚àÇu/‚àÇt = L*u + N(u). Array L includes the coefficients of the linear term L*u and calcN! is a function which computes the nonlinear term N(u). The struct also includes the problem's grid and the float type of the state vector (and consequently of N(u)).\n\nL::Any\narray with coefficient for the linear part of the equation\ncalcN!::Function\nfunction that computes the nonlinear part of the equation\ngrid::AbstractGrid{G, A, Alias} where {G<:AbstractFloat, A, Alias}\nthe grid\ndims::Tuple\nthe dimensions of L\nT::Any\nthe float type for the state vector\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#FourierFlows.Equation-Union{Tuple{G}, Tuple{Any, Any, AbstractGrid{G, A, Alias} where {A, Alias}}} where G","page":"Private","title":"FourierFlows.Equation","text":"Equation(L, calcN!, grid; dims=supersize(L), T=nothing)\n\nThe equation constructor from the array L of the coefficients of the linear term, the function  calcN! that computes the nonlinear term and the grid for the problem.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#FourierFlows.Problem","page":"Private","title":"FourierFlows.Problem","text":"struct Problem{T, A<:AbstractArray, Tg<:AbstractFloat, TL}\n\nA problem that represents a partial differential equation.\n\nsol::AbstractArray\nthe state vector\nclock::FourierFlows.Clock{Tg} where Tg<:AbstractFloat\nthe problem's\neqn::FourierFlows.Equation{T, TL, Tg} where {T, Tg<:AbstractFloat, TL}\nthe equation\ngrid::AbstractGrid{Tg, A, Alias} where {Tg<:AbstractFloat, A, Alias}\nthe grid\nvars::AbstractVars\nthe variables\nparams::AbstractParams\nthe parameters\ntimestepper::AbstractTimeStepper{A} where A<:AbstractArray\nthe timestepper\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#FourierFlows.Problem-Union{Tuple{T}, Tuple{FourierFlows.Equation, Any, Any, AbstractGrid{T, A, Alias} where {A, Alias}}, Tuple{FourierFlows.Equation, Any, Any, AbstractGrid{T, A, Alias} where {A, Alias}, Any}, Tuple{FourierFlows.Equation, Any, Any, AbstractGrid{T, A, Alias} where {A, Alias}, Any, Any}, Tuple{FourierFlows.Equation, Any, Any, AbstractGrid{T, A, Alias} where {A, Alias}, Any, Any, Device}} where T","page":"Private","title":"FourierFlows.Problem","text":"Problem(eqn::Equation, stepper, dt, grid::AbstractGrid{T}, \n        vars=EmptyVars, params=EmptyParams, dev::Device=CPU(); stepperkwargs...) where T\n\nConstruct a Problem for equation eqn using the timestepper with timestep  dt, on grid and on device. Optionally, use the keyword arguments to provide  variables with vars and parameters with params. The stepperkwargs are passed to the time-stepper constructor.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#Domain","page":"Private","title":"Domain","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [FourierFlows]\nPublic  = false\nPages   = [\"domains.jl\"]","category":"page"},{"location":"library/internals/#FourierFlows.getaliasedwavenumbers-Tuple{Any, Any, Any}","page":"Private","title":"FourierFlows.getaliasedwavenumbers","text":"getaliasedwavenumbers(nk, nkr, aliased_fraction)\n\nReturns the top aliased_fraction highest wavenumbers, both for and real FFTs, kalias and  kralias respectively. For example, aliased_fraction=1/3 should return the indices of the  top-most 1/6-th (in absolute value) for both positive and negative wavenumbers (i.e., 1/3 total)  that should be set to zero after performing an FFT. \n\n\n\n\n\n","category":"method"},{"location":"library/internals/#FourierFlows.griddevice-Union{Tuple{AbstractGrid{T, A, Alias} where Alias}, Tuple{A}, Tuple{T}} where {T, A}","page":"Private","title":"FourierFlows.griddevice","text":"griddevice(grid)\n\nReturns the device on which the grid lives on.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#FourierFlows.makefilter-Tuple{Array}","page":"Private","title":"FourierFlows.makefilter","text":"makefilter(K; order=4, innerK=0.65, outerK=1)\n\nReturns a filter acting on the non-dimensional wavenumber K that decays exponentially for K>innerK, thus removing high-wavenumber content from a spectrum it is multiplied with. The decay rate is determined by order and outerK determines the outer wavenumber at which the filter is smaller than Float64 machine precision.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#Utilities","page":"Private","title":"Utilities","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [FourierFlows]\nPublic  = false\nPages   = [\"utils.jl\"]","category":"page"},{"location":"library/internals/#FourierFlows.jacobian-Tuple{Any, Any, TwoDGrid}","page":"Private","title":"FourierFlows.jacobian","text":"jacobian(a, b, grid)\n\nReturns the Jacobian of a and b on grid.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#FourierFlows.jacobianh-Tuple{Any, Any, TwoDGrid}","page":"Private","title":"FourierFlows.jacobianh","text":"jacobianh(a, b, grid)\n\nReturns the Fourier transform of the Jacobian of a and b on grid.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#FourierFlows.on_grid-Union{Tuple{A}, Tuple{T}, Tuple{Any, OneDGrid{T, A, Tx, Tfft, Trfft, Talias} where {Tx, Tfft, Trfft, Talias}}} where {T, A}","page":"Private","title":"FourierFlows.on_grid","text":"on_grid(func, grid)\n\nReturns an array, of the ArrayType of the device grid lives on, that contains the values of function func evaluated on the grid.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#FourierFlows.parsevalsum-Tuple{Any, TwoDGrid}","page":"Private","title":"FourierFlows.parsevalsum","text":"parsevalsum(uh, grid)\n\nReturns real(Œ£ uh) on the grid, i.e.\n\n‚Ñú  sum_ùê§ u_ùê§ L_x L_y  \n\nwhere u_ùê§ = uh ( grid.nx e^- i ùê§  ùê±‚ÇÄ), with ùê±‚ÇÄ the vector with components the left-most position in each direction.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#FourierFlows.parsevalsum2-Tuple{Any, TwoDGrid}","page":"Private","title":"FourierFlows.parsevalsum2","text":"parsevalsum2(uh, grid)\n\nReturns Œ£ |uh|¬≤ on the grid, which is equal to the domain integral of u. More specifically,  it returns\n\nsum_ùê§ u_ùê§¬≤ L_x L_y = int u(ùê±)¬≤  ùñΩx ùñΩy \n\nwhere u_ùê§ = uh ( grid.nx e^- i ùê§  ùê±‚ÇÄ), with ùê±‚ÇÄ the vector with components the left-most position in each direction.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#FourierFlows.radialspectrum-Tuple{Any, TwoDGrid}","page":"Private","title":"FourierFlows.radialspectrum","text":"radialspectrum(fh, grid; n=nothing, m=nothing, refinement=2)\n\nReturns the radial spectrum of fh. fh lives on Cartesian wavenumber grid (k l). To  compute the radial spectrum, we first interpolate f(k l) onto a radial wavenumber grid  (œÅ Œ∏), where œÅ¬≤ = k¬≤+l¬≤ and Œ∏ = arctan(lk). Note here that  f = fh ( grid.nx e^- i ùê§  ùê±‚ÇÄ),  with ùê±‚ÇÄ the vector with components the  left-most position in each direction. After interpolation, we integrate fover angles Œ∏  to get fœÅ,\n\n  f_œÅ = int f(œÅ Œ∏) œÅ ùñΩœÅ ùñΩŒ∏  \n\nThe resolution (n, m) for the polar wavenumber grid is n = refinement * maximum(nk, nl),  m = refinement * maximum(nk, nl), where refinement = 2 by default. If fh is in conjugate  symmetric form then only the upper-half plane in Œ∏ is represented on the polar grid.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#Diagnostics","page":"Private","title":"Diagnostics","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [FourierFlows]\nPublic  = false\nPages   = [\"diagnostics.jl\"]","category":"page"},{"location":"library/internals/#Base.getindex-Tuple{Diagnostic, Union{AbstractString, Symbol}}","page":"Private","title":"Base.getindex","text":"e.g. plot(energydiag[:t], energydiag[:data]).\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#FourierFlows.extend!-Tuple{Any, Any}","page":"Private","title":"FourierFlows.extend!","text":"extend!(diag, n)\n\nExtend the data, time, and steps vectors of the diagnostic diag by n.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#FourierFlows.extend!-Union{Tuple{Diagnostic{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"Private","title":"FourierFlows.extend!","text":"extend!(diag::Diagnostic{T,N})\n\nDouble the extend of the data, time, and steps vectors of the diagnostic diag.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#Output","page":"Private","title":"Output","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [FourierFlows]\nPublic  = false\nPages   = [\"output.jl\"]","category":"page"},{"location":"library/internals/#FourierFlows.savefield-Tuple{Any, Any, Any}","page":"Private","title":"FourierFlows.savefield","text":"savefield(file, location, data)\n\nSaves a particular field's data to file.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#FourierFlows.savefields-Tuple{JLD2.JLDFile{JLD2.MmapIO}, TwoDGrid}","page":"Private","title":"FourierFlows.savefields","text":"savefields(file, grid)\n\nSaves some parameters of problem's grid to file.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#FourierFlows.uniquepath-Tuple{Any}","page":"Private","title":"FourierFlows.uniquepath","text":"uniquepath(path)\n\nReturn path with a number appended if isfile(path) == true. The number is incremented until path does not exist.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#Timesteppers","page":"Private","title":"Timesteppers","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [FourierFlows]\nPublic = false\nPages   = [\"timesteppers.jl\"]","category":"page"},{"location":"library/internals/#FourierFlows.getetdcoeffs-Tuple{Any, Any}","page":"Private","title":"FourierFlows.getetdcoeffs","text":"getetdcoeffs(dt, L; ncirc=32, rcirc=1)\n\nCalculate ETDRK4 coefficients associated with the (diagonal) linear coefficient L by integrating over a small circle in complex space.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#Diffusion-Testbed-Module","page":"Private","title":"Diffusion Testbed Module","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [FourierFlows.Diffusion]\nPublic  = false\nPages   = [\"diffusion.jl\"]","category":"page"},{"location":"library/internals/#FourierFlows.Diffusion.Params","page":"Private","title":"FourierFlows.Diffusion.Params","text":"struct Params{T} <: AbstractParams\n\nThe parameters for diffusion problem:\n\nŒ∫::Any\ndiffusivity coefficient\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#FourierFlows.Diffusion.Vars","page":"Private","title":"FourierFlows.Diffusion.Vars","text":"struct Vars{Aphys, Atrans} <: AbstractVars\n\nThe variables for diffusion problem:\n\nc\ntracer concentration\ncx\ntracer concentration derivative ‚àÇ‚Çìc\nch\nFourier transform of tracer concentration\ncxh\nFourier transform of tracer concentration derivative ‚àÇ‚Çìc\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#FourierFlows.Diffusion.Vars-Union{Tuple{T}, Tuple{Dev}, Tuple{Dev, AbstractGrid{T, A, Alias} where {A, Alias}}} where {Dev, T}","page":"Private","title":"FourierFlows.Diffusion.Vars","text":"Vars(dev, grid)\n\nReturn the variables vars for a constant diffusivity problem on grid.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#FourierFlows.Diffusion.Equation-Union{Tuple{T}, Tuple{Device, T, Any}} where T<:Number","page":"Private","title":"FourierFlows.Diffusion.Equation","text":"Equation(dev, Œ∫, grid)\n\nReturn the equation for a constant diffusivity problem on grid with diffusivity Œ∫.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#FourierFlows.Diffusion.calcN!-Union{Tuple{T}, Tuple{Any, Any, Any, Any, Any, FourierFlows.Diffusion.Params{T}, Any}} where T<:Number","page":"Private","title":"FourierFlows.Diffusion.calcN!","text":"calcN!(N, sol, t, clock, vars, params, grid)\n\nCalculate the nonlinear term for the 1D diffusion equation.\n\n\n\n\n\n","category":"method"},{"location":"grids/#Grids","page":"Grids","title":"Grids","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"1D, 2D, and 3D grids are supported. We demonstrate here the construction of a  one-dimensional grid and how one can use it to perform Fourier transforms and  compute spatial derivatives.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"A one-dimensional grid with n_x = 64 grid points and length L_x = 2 pi is  constructed by","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"DocTestSetup = quote\n    using FourierFlows\nend","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"julia> using FourierFlows\n\njulia> nx, Lx = 64, 2œÄ;\n\njulia> grid = OneDGrid(nx, Lx)\nOneDimensionalGrid\n  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Device: CPU\n  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FloatType: Float64\n  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ size Lx: 6.283185307179586\n  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ resolution nx: 64\n  ‚îú‚îÄ‚îÄ grid spacing dx: 0.09817477042468103\n  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ domain: x ‚àà [-3.141592653589793, 3.0434178831651124]\n  ‚îî‚îÄ aliased fraction: 0.3333333333333333","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"The grid domain is, by default, constructed symmetrically around x = 0, but this can be  altered using the x0 keyword argument of the OneDGrid constructor. The grid spacing  is L_x  n_x. Note that the last point of the domain is a grid-spacing before L_x  2.  This is because periodicity implies that the values of any field at the end-points of the  domain are equal and, therefore, grid-point values at both these end-points are redundant.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"We can define an array u that contains the values of a function u(x) on this  grid as","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"using FourierFlows\nusing LinearAlgebra: mul!, ldiv!\nusing Plots\nPlots.default(lw=3)\nnx, Lx = 64, 2œÄ\ngrid = OneDGrid(nx, Lx)","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"u = @. sin(2 * grid.x) + 1/2 * cos(5 * grid.x)\n\nnothing # hide","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"Note that we chose a function that is periodic on our domain. We can visualize u by","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"using Plots\n\nplot(grid.x, u, label=\"u\", xlabel=\"x\")\nsavefig(\"assets/plot1.svg\"); nothing # hide","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"(Image: )","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"Function u(x) can be expanded in Fourier series:","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"u(x) = sum_k hatu(k)  e^i k x ","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"where hatu(k) is Fourier transform of u(x) and k the discrete set of  wavenumbers that fit within our finite domain. We can compute hatu via a  Fast Fourier Transform (FFT). Since our u array is real-valued then we should  use the real-FFT algorithm. The real-valued FFT transform only saves the Fourier  coefficients for k ge 0; the coefficients for negative wavenumbers can be  obtained via hatu(-k) = hatu(k)^*.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"The wavenumbers used in FFT are contained in grid.k and they are ordered as:","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"frac2piL_x  0 1 dots n_x2-1 -n_x2 -n_x2+1 dots -1  ","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"while the wavenumbers for real FFT are in grid.kr:","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"frac2piL_x  0 1 dots n_x2-1  ","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"The grid also includes the FFT plans for both real-valued and complex valued transforms:","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"grid.fftplan","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"grid.rfftplan","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"We use the convention that variables names with h at the end stand for variable-hat, i.e.,  hatu  is the Fourier transform of u and is stored in array uh. Since u is of  size n_x, the real-Fourier transform should be of size n_kr = n_x2+1.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"uh = Complex.(zeros(grid.nkr))\n\nnothing # hide","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"The FFT transform is done as an in-place matrix multiplication using mul!.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"using LinearAlgebra: mul!\n\nmul!(uh, grid.rfftplan, u)\n\nnothing # hide","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"The FFT algorithm does not output exactly the Fourier coefficients hatu(k) but rather due to different normalization, FFT outputs something proportional to hatu(k).  To obtain hatu we need to divide the FFT output by the length of the  original array and by e^-i k x_0, where x_0 is the first  point of our domain array.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"uhat = @. uh / (nx * exp(- im * grid.kr * grid.x[1])) # due to normalization of FFT\n\nplot(grid.kr, [real.(uhat), imag.(uhat)],\n          label = [\"real( uÃÇ )\" \"imag( uÃÇ )\"],\n         xlabel = \"k\",\n          xlims = (-0.5, 10.5),\n          ylims = (-0.55, 0.55),\n         xticks = 0:10,\n         yticks = -0.5:0.25:0.5,\n         marker = :auto)\n\nsavefig(\"assets/plot2.svg\"); nothing # hide","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"(Image: )","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"We can compute its derivative via Fourier transforms. To do that we can use the FFTW plans that are constructed with the grid. First we allocate some empty arrays where the values of the derivative in physical and Fourier space will be stored,","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"‚àÇ‚Çìu  = similar(u)\n‚àÇ‚Çìuh = similar(uh)\nnothing # hide","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"The grid contains the wavenumbers (both for real-value functions grid.kr and  for complex-valued functions grid.k). We populate array ‚àÇ‚Çìuh is with i k hatu:","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"@. ‚àÇ‚Çìuh = im * grid.kr * uh\n\nnothing # hide","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"Then the derivative in physical space, ‚àÇ‚Çìu, is obtained with an inverse Fourier  tranform. The latter is obtained again using the FFTW plans but now via ldiv!:","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"using LinearAlgebra: ldiv!\n\nldiv!(‚àÇ‚Çìu, grid.rfftplan, ‚àÇ‚Çìuh)\n\nplot(grid.x, [u ‚àÇ‚Çìu], label=[\"u\" \"‚àÇu/‚àÇx\"], xlabel=\"x\")\n\nsavefig(\"assets/plot3.svg\"); nothing # hide","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"(Image: )","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"EditURL = \"https://github.com/FourierFlows/FourierFlowsDocumentation/blob/main/examples/OneDShallowWaterGeostrophicAdjustment.jl\"","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/#Linear-rotating-shallow-water-dynamics","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"","category":"section"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"This example can be run online via (Image: ). Also, it can be viewed as a Jupyter notebook via (Image: ).","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"This example solves the linear 1D rotating shallow water equations for the u(x t), v(x t) and the surface surface elevation eta(x t), for a fluid with constant rest-depth H. That is, the total fluid's depth is H + eta(x t) with eta ll H.","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"The linearized equations for the evolution of u, v, eta are:","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"beginaligned\npartial_t u - f v  = - g partial_x eta - mathrmD u \npartial_t v + f u  = - mathrmD v \npartial_t eta + H partial_x u  = - mathrmD eta\nendaligned","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"Above, g is the gravitational acceleration, f is the  Coriolis parameter, and mathrmD indicates a hyperviscous linear operator of the form (-1)^n_ŒΩ ŒΩ nabla^2 n_ŒΩ, with ŒΩ the viscosity coefficient and n_ŒΩ the order of the operator.","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"Rotation introduces the deformation length scale, L_d = sqrtg H  f. Disturbances with length scales much smaller than L_d don't \"feel\" the rotation and propagate as inertia-gravity waves. Disturbances with length scales comparable or larger than L_d should be approximately in geostrophic balance, i.e., the Coriolis acceleration f widehatbmz times bmu should be in approximate balance with the pressure gradient -g bmnabla eta.","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"using FourierFlows, Plots, Printf, Random\nusing LinearAlgebra: mul!, ldiv!","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/#Coding-up-the-equations","page":"Linear rotating shallow water dynamics","title":"Coding up the equations","text":"","category":"section"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/#A-demonstration-of-FourierFlows.jl-framework","page":"Linear rotating shallow water dynamics","title":"A demonstration of FourierFlows.jl framework","text":"","category":"section"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"What follows is a step-by-step tutorial demonstrating how you can create your own solver for an equation of your liking.","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"The basic building blocks for a FourierFlows.Problem are:","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"Grid struct containining the physical and wavenumber grid for the problem,\nParams struct containining all the parameters of the problem,\nVars struct containining arrays with the variables used in the problem,\nEquation struct containining the coefficients of the linear operator L and the function that computes the nonlinear terms, usually named calcN!().","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"The Grid structure is provided by FourierFlows.jl. We simply have to call one of either OneDGrid(), TwoDGrid(), or ThreeDGrid() constructors, depending on the dimensionality of the problem. All other structs mentioned above are problem-specific and need to be constructed for every set of equations we want to solve.","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"First let's construct the Params struct that contains all parameters of the problem.","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"struct Params{T} <: AbstractParams\n   ŒΩ :: T         # Hyperviscosity coefficient\n  nŒΩ :: Int       # Order of the hyperviscous operator\n   g :: T         # Gravitational acceleration\n   H :: T         # Fluid depth\n   f :: T         # Coriolis parameter\nend\nnothing #hide","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"Now the Vars struct that contains all variables used in this problem. For this problem Vars includes the representations of the flow fields in physical space u, v and Œ∑ and their Fourier transforms uh, vh, and Œ∑h.","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"struct Vars{Aphys, Atrans} <: AbstractVars\n   u :: Aphys\n   v :: Aphys\n   Œ∑ :: Aphys\n  uh :: Atrans\n  vh :: Atrans\n  Œ∑h :: Atrans\nend\nnothing #hide","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"A constructor populates empty arrays based on the dimension of the grid and then creates Vars struct.","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"\"\"\"\n    Vars(dev, grid)\nConstructs Vars for 1D shallow water based on the dimensions of arrays of the `grid`.\n\"\"\"\nfunction Vars(::Dev, grid) where Dev\n  T = eltype(grid)\n  @devzeros Dev T grid.nx u v Œ∑\n  @devzeros Dev Complex{T} grid.nkr uh vh Œ∑h\n\n  return Vars(u, v, Œ∑, uh, vh, Œ∑h)\nend\nnothing #hide","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"In Fourier space, the 1D linear shallow water dynamics read:","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"beginaligned\nfracpartial hatupartial t  = underbrace f hatv - i k g hateta _N_u  underbrace- nu k^2 _L_u hatu  \nfracpartial hatvpartial t  = underbrace - f hatu _N_v  underbrace- nu k^2 _L_v hatv  \nfracpartial hatetapartial t  = underbrace - i k H hatu _N_eta  underbrace- nu k^2 _L_eta hateta \nendaligned","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"Although, e.g., terms involving the Coriolis accelaration are, in principle, linear we include them in the nonlinear term N because they render the linear operator L non-diagonal.","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"With these in mind, we construct function calcN! that computes the nonlinear terms.","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"\"\"\"\n    calcN!(N, sol, t, clock, vars, params, grid)\nCompute the nonlinear terms for 1D linear shallow water dynamics.\n\"\"\"\nfunction calcN!(N, sol, t, clock, vars, params, grid)\n  @. vars.uh = sol[:, 1]\n  @. vars.vh = sol[:, 2]\n  @. vars.Œ∑h = sol[:, 3]\n\n  @. N[:, 1] =   params.f * vars.vh - im * grid.kr * params.g * vars.Œ∑h    #  + f v - g ‚àÇŒ∑/‚àÇx\n  @. N[:, 2] = - params.f * vars.uh                                        #  - f u\n  @. N[:, 3] = - im * grid.kr * params.H * vars.uh                         #  - H ‚àÇu/‚àÇx\n\n  dealias!(N, grid)\n\n  return nothing\nend\nnothing #hide","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"Next we construct the Equation struct:","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"\"\"\"\n    Equation(dev, params, grid)\nConstruct the equation: the linear part, in this case the hyperviscous dissipation,\nand the nonlinear part, which is computed by `calcN!` function.\n\"\"\"\nfunction Equation(dev, params, grid)\n  T = eltype(grid)\n  L = zeros(dev, T, (grid.nkr, 3))\n  D = @. - params.ŒΩ * grid.kr^(2*params.nŒΩ)\n\n  L[:, 1] .= D # for u equation\n  L[:, 2] .= D # for v equation\n  L[:, 3] .= D # for Œ∑ equation\n\n  return FourierFlows.Equation(L, calcN!, grid)\nend\nnothing #hide","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"We now have all necessary building blocks to construct a FourierFlows.Problem. It would be useful, however, to define some more \"helper functions\". For example, a function that updates all variables given the solution sol which comprises hatu, hatv and hateta:","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"\"\"\"\n    updatevars!(prob)\nUpdate the variables in `prob.vars` using the solution in `prob.sol`.\n\"\"\"\nfunction updatevars!(prob)\n  vars, grid, sol = prob.vars, prob.grid, prob.sol\n\n  @. vars.uh = sol[:, 1]\n  @. vars.vh = sol[:, 2]\n  @. vars.Œ∑h = sol[:, 3]\n\n  ldiv!(vars.u, grid.rfftplan, deepcopy(sol[:, 1])) # use deepcopy() because irfft destroys its input\n  ldiv!(vars.v, grid.rfftplan, deepcopy(sol[:, 2])) # use deepcopy() because irfft destroys its input\n  ldiv!(vars.Œ∑, grid.rfftplan, deepcopy(sol[:, 3])) # use deepcopy() because irfft destroys its input\n\n  return nothing\nend\nnothing #hide","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"Another useful function is one that prescribes an initial condition to the state variable sol.","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"\"\"\"\n    set_uvŒ∑!(prob, u0, v0, Œ∑0)\nSets the state variable `prob.sol` as the Fourier transforms of `u0`, `v0`, and `Œ∑0`\nand update all variables in `prob.vars`.\n\"\"\"\nfunction set_uvŒ∑!(prob, u0, v0, Œ∑0)\n  vars, grid, sol = prob.vars, prob.grid, prob.sol\n\n  A = typeof(vars.u) # determine the type of vars.u\n\n  mul!(vars.uh, grid.rfftplan, A(u0)) # A(u0) converts u0 to the same type as vars expects (useful if u0 is a CPU array while working on the GPU)\n  mul!(vars.vh, grid.rfftplan, A(v0)) # A(v0) converts u0 to the same type as vars expects (useful if v0 is a CPU array while working on the GPU)\n  mul!(vars.Œ∑h, grid.rfftplan, A(Œ∑0)) # A(Œ∑0) converts u0 to the same type as vars expects (useful if Œ∑0 is a CPU array while working on the GPU)\n\n  @. sol[:, 1] = vars.uh\n  @. sol[:, 2] = vars.vh\n  @. sol[:, 3] = vars.Œ∑h\n\n  updatevars!(prob)\n\n  return nothing\nend\nnothing #hide","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/#Let's-prescibe-parameter-values-and-solve-the-PDE","page":"Linear rotating shallow water dynamics","title":"Let's prescibe parameter values and solve the PDE","text":"","category":"section"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"We are now ready to write up a program that sets up parameter values, constructs the problem prob, # time steps the solutions prob.sol and plots it.","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/#Choosing-a-device:-CPU-or-GPU","page":"Linear rotating shallow water dynamics","title":"Choosing a device: CPU or GPU","text":"","category":"section"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"dev = CPU()    # Device (CPU/GPU)\nnothing # hide","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/#Numerical-parameters-and-time-stepping-parameters","page":"Linear rotating shallow water dynamics","title":"Numerical parameters and time-stepping parameters","text":"","category":"section"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"     nx = 512            # grid resolution\nstepper = \"FilteredRK4\"  # timestepper\n     dt = 20.0           # timestep (s)\n nsteps = 320            # total number of time-steps\nnothing # hide","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/#Physical-parameters","page":"Linear rotating shallow water dynamics","title":"Physical parameters","text":"","category":"section"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"Lx = 500e3      # Domain length (m)\ng  = 9.8        # Gravitational acceleration (m s‚Åª¬≤)\nH  = 200.0      # Fluid depth (m)\nf  = 1e-2       # Coriolis parameter (s‚Åª¬π)\nŒΩ  = 100.0      # Viscosity (m¬≤ s‚Åª¬π)\nnŒΩ = 1          # Viscosity order (nŒΩ = 1 means Laplacian ‚àá¬≤)\nnothing # hide","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/#Construct-the-structs-and-you-are-ready-to-go!","page":"Linear rotating shallow water dynamics","title":"Construct the structs and you are ready to go!","text":"","category":"section"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"Create a grid and also params, vars, and the equation structs. Then give them all as input to the FourierFlows.Problem() constructor to get a problem struct, prob, that contains all of the above.","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"    grid = OneDGrid(dev, nx, Lx)\n  params = Params(ŒΩ, nŒΩ, g, H, f)\n    vars = Vars(dev, grid)\nequation = Equation(dev, params, grid)\n\n    prob = FourierFlows.Problem(equation, stepper, dt, grid, vars, params, dev)\nnothing #hide","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/#Setting-initial-conditions","page":"Linear rotating shallow water dynamics","title":"Setting initial conditions","text":"","category":"section"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"For initial condition we take the fluid at rest (u = v = 0). The free surface elevation is perturbed from its rest position (eta=0); the disturbance we impose a Gaussian bump with half-width greater than the deformation radius and on top of that we superimpose some random noise with scales smaller than the deformation radius. We mask the small-scale perturbations so that it only applies in the central part of the domain by applying","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"The system develops geostrophically-balanced jets around the Gaussian bump, while the smaller-scale noise propagates away as inertia-gravity waves.","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"First let's construct the Gaussian bump.","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"gaussian_width = 6e3\ngaussian_amplitude = 3.0\ngaussian_bump = @. gaussian_amplitude * exp( - grid.x^2 / (2*gaussian_width^2) )\n\nplot(grid.x/1e3, gaussian_bump,    # divide with 1e3 to convert m -> km\n     color = :black,\n    legend = false,\n linewidth = 2,\n     alpha = 0.7,\n     xlims = (-Lx/2e3, Lx/2e3),\n    xlabel = \"x [km]\",\n    ylabel = \"Œ∑ [m]\",\n     title = \"A gaussian bump with half-width ‚âà \"*string(gaussian_width/1e3)*\" km\",\n      size = (600, 260))","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"Next the noisy perturbation. The mask is simply a product of hyperbolic tangent functions.","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"mask = @. 1/4 * (1 + tanh( -(grid.x - 100e3) / 10e3)) * (1 + tanh( (grid.x + 100e3) / 10e3))\n\nnoise_amplitude = 0.1 # the amplitude of the noise for Œ∑(x,t=0) (m)\nŒ∑_noise = noise_amplitude * Random.randn(size(grid.x))\n@. Œ∑_noise *= mask    # mask the noise\n\nplot_noise = plot(grid.x/1e3, Œ∑_noise,      # divide with 1e3 to convert m -> km\n                 color = :black,\n                legend = :false,\n             linewidth = [3 2],\n                 alpha = 0.7,\n                 xlims = (-Lx/2e3, Lx/2e3), # divide with 1e3 to convert m -> km\n                 ylims = (-0.3, 0.3),\n                xlabel = \"x [km]\",\n                ylabel = \"Œ∑ [m]\")\n\nplot_mask = plot(grid.x/1e3, mask,          # divide with 1e3 to convert m -> km\n                 color = :gray,\n                legend = :false,\n             linewidth = [3 2],\n                 alpha = 0.7,\n                 xlims = (-Lx/2e3, Lx/2e3), # divide with 1e3 to convert m -> km\n                xlabel = \"x [km]\",\n                ylabel = \"mask\")\n\ntitle = plot(title = \"Small-scale noise\",\n              grid = false,\n          showaxis = false,\n            xticks = [],\n            yticks = [],\n     bottom_margin = -20Plots.px)\n\nplot(title, plot_noise, plot_mask,\n           layout = @layout([A{0.01h}; [B; C]]),\n             size = (600, 400))","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"Sum the Gaussian bump and the noise and then call set_uvŒ∑!() to set the initial condition to the problem prob.","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"Œ∑0 = @. gaussian_bump + Œ∑_noise\nu0 = zeros(grid.nx)\nv0 = zeros(grid.nx)\n\nset_uvŒ∑!(prob, u0, v0, Œ∑0)\n\nplot(grid.x/1e3, Œ∑0,    # divide with 1e3 to convert m -> km\n     color = :black,\n    legend = false,\n linewidth = 2,\n     alpha = 0.7,\n     xlims = (-Lx/2e3, Lx/2e3),\n    xlabel = \"x [km]\",\n    ylabel = \"Œ∑ [m]\",\n     title = \"initial surface elevation, Œ∑(x, t=0)\",\n      size = (600, 260))","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/#Visualizing-the-simulation","page":"Linear rotating shallow water dynamics","title":"Visualizing the simulation","text":"","category":"section"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"We define a function that plots the surface elevation eta and the depth-integrated velocities u and v.","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"function plot_output(prob)\n  plot_Œ∑ = plot(grid.x/1e3, vars.Œ∑,         # divide with 1e3 to convert m -> km\n                 color = :blue,\n                legend = false,\n             linewidth = 2,\n                 alpha = 0.7,\n                 xlims = (-Lx/2e3, Lx/2e3), # divide with 1e3 to convert m -> km\n                xlabel = \"x [km]\",\n                ylabel = \"Œ∑ [m]\")\n\n  plot_u = plot(grid.x/1e3, vars.u,         # divide with 1e3 to convert m -> km\n                 color = :red,\n                legend = false,\n             linewidth = 2,\n                 alpha = 0.7,\n                 xlims = (-Lx/2e3, Lx/2e3), # divide with 1e3 to convert m -> km\n                 ylims = (-0.3, 0.3),\n                xlabel = \"x [km]\",\n                ylabel = \"u [m s‚Åª¬π]\")\n\n  plot_v = plot(grid.x/1e3, vars.v,         # divide with 1e3 to convert m -> km\n                 color = :green,\n                legend = false,\n             linewidth = 2,\n                 alpha = 0.7,\n                 xlims = (-Lx/2e3, Lx/2e3), # divide with 1e3 to convert m -> km\n                 ylims = (-0.3, 0.3),\n                xlabel = \"x [km]\",\n                ylabel = \"v [m s‚Åª¬π]\")\n\n  Ld = @sprintf \"%.2f\" sqrt(g*H)/f /1e3     # divide with 1e3 to convert m -> km\n  plottitle = \"Deformation radius ‚àö(gh) / f = \"*string(Ld)*\" km\"\n\n  title = plot(title = plottitle,\n                grid = false,\n            showaxis = false,\n              xticks = [],\n              yticks = [],\n       bottom_margin = -30Plots.px)\n\n  return plot(title, plot_Œ∑, plot_u, plot_v,\n           layout = @layout([A{0.01h}; [B; C; D]]),\n             size = (600, 800))\nend\nnothing # hide","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/#Time-stepping-the-Problem-forward","page":"Linear rotating shallow water dynamics","title":"Time-stepping the Problem forward","text":"","category":"section"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"We time-step the Problem forward in time. We update variables by calling updatevars!() and we also update the plot. We enclose the for loop in an @animate macro to produce an animation of the solution.","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"p = plot_output(prob)\n\nanim = @animate for j = 0:nsteps\n  updatevars!(prob)\n\n  p[2][1][:y] = vars.Œ∑    # updates the plot for Œ∑\n  p[2][:title] = \"t = \" * @sprintf(\"%.1f\", prob.clock.t/60) * \" min\" # updates time in the title\n  p[3][1][:y] = vars.u    # updates the plot for u\n  p[4][1][:y] = vars.v    # updates the plot for v\n\n  stepforward!(prob)\nend\n\nmp4(anim, \"onedshallowwater.mp4\", fps=18)","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/#Geostrophic-balance","page":"Linear rotating shallow water dynamics","title":"Geostrophic balance","text":"","category":"section"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"It is instructive to compare the solution for v with its geostrophically balanced approximation, f widehatbmz times bmu_rm geostrophic = - g bmnabla eta, i.e.,","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"beginaligned\nv_rm geostrophic  =   fracgf fracpartial etapartial x   \nu_rm geostrophic  = - fracgf fracpartial etapartial y = 0  \nendaligned","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"The geostrophic solution should capture well the the behavior of the flow in the center of the domain, after small-scale disturbances propagate away.","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"u_geostrophic = zeros(grid.nx)  # -g/f ‚àÇŒ∑/‚àÇy = 0\nv_geostrophic = params.g / params.f * irfft(im * grid.kr .* vars.Œ∑h, grid.nx)  #g/f ‚àÇŒ∑/‚àÇx\n\nplot_u = plot(grid.x/1e3, [vars.u u_geostrophic], # divide with 1e3 to convert m -> km\n                 color = [:red :purple],\n                labels = [\"u\" \"- g/f ‚àÇŒ∑/‚àÇy\"],\n             linewidth = [3 2],\n                 alpha = 0.7,\n                 xlims = (-Lx/2e3, Lx/2e3),       # divide with 1e3 to convert m -> km\n                 ylims = (-0.3, 0.3),\n                xlabel = \"x [km]\",\n                ylabel = \"u [m s‚Åª¬π]\")\n\nplot_v = plot(grid.x/1e3, [vars.v v_geostrophic], # divide with 1e3 to convert m -> km\n                 color = [:green :purple],\n                labels = [\"v\" \"g/f ‚àÇŒ∑/‚àÇx\"],\n             linewidth = [3 2],\n                 alpha = 0.7,\n                 xlims = (-Lx/2e3, Lx/2e3),       # divide with 1e3 to convert m -> km\n                 ylims = (-0.3, 0.3),\n                xlabel = \"x [km]\",\n                ylabel = \"v [m s‚Åª¬π]\")\n\ntitle = plot(title = \"Geostrophic balance\",\n              grid = false,\n          showaxis = false,\n            xticks = [],\n            yticks = [],\n     bottom_margin = -20Plots.px)\n\nplot(title, plot_u, plot_v,\n           layout = @layout([A{0.01h}; [B; C]]),\n             size = (600, 400))","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"","category":"page"},{"location":"literated/OneDShallowWaterGeostrophicAdjustment/","page":"Linear rotating shallow water dynamics","title":"Linear rotating shallow water dynamics","text":"This page was generated using Literate.jl.","category":"page"},{"location":"library/function_index/#main-index","page":"Function index","title":"Index","text":"","category":"section"},{"location":"library/function_index/","page":"Function index","title":"Function index","text":"Pages = [\"public.md\", \"internals.md\", \"function_index.md\"]","category":"page"},{"location":"problem/#problem_docs","page":"Problem","title":"Problem","text":"","category":"section"},{"location":"problem/","page":"Problem","title":"Problem","text":"using FourierFlows, Plots\nusing LinearAlgebra: mul!, ldiv!\nPlots.default(lw=3)","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"Everything needed to solve a PDE in FourierFlows.jl is gathered in a composite type named Problem. Problem contains various other composite types (see Problem for details).","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"Here, we demonstrate how we can construct a Problem to solve the simple 1D equation:","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"partial_t u(x t) = - alpha  u(x t) ","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"on domain x in -1 1.","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"First, we construct our grid","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"using FourierFlows\n\nnx, Lx = 32, 2.0\n\ngrid = OneDGrid(nx, Lx)","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"Our problem has a parameter alpha. Thus, we create a Params as:","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"struct Params <: AbstractParams\n  Œ± :: Float64\nend","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"and then we use the Params's constructor to populate our params with the parameter value,  e.g., alpha = 01:","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"Œ± = 0.1\n\nparams = Params(Œ±)","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"The particular equation is so simple that it makes no difference performance-wise whether  we time-step it in physical or in wavenumber space. For PDEs with nonlinear terms,  time-stepping in wavenumber space is much more efficient. Thus, for demonstration purposes,  we will time-step the equation in wavenumber space, i.e.,","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"partial_t hatu(k t) = - alpha  hatu(k t) ","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"The variables involved are u and its Fourier transform hatu. Thus, we  construct the vars as:","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"struct Vars <: AbstractVars\n    u :: Array{Float64,1}\n   uh :: Array{Complex{Float64}, 1}\nend","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"and, like before, we use the Vars's constructor to populate the vars with  zero arrays,","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"vars = Vars(zeros(Float64, (grid.nx,)), zeros(Complex{Float64}, (grid.nkr,)))","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"Note that the Fourier transform of a real-valued array u is complex-valued. Also because we use the real Fourier transform, the array uh is smaller.","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"In this simple example our state variable is simply uh, i.e., sol = uh.","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"Next we need to construct the equation. Equation contains the linear coefficients  for the linear part of the PDE, stored in an array L, and the function calcN!() that  calculates the nonlinear terms from the state variable sol. In our case, our equation is linear and, therefore,","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"L = - params.Œ± * ones(grid.nkr)\n\nnothing # hide","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"and","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"function calcN!(N, sol, t, clock, vars, params, grid)\n  @. N = 0\n  \n  return nothing\nend\n\nnothing # hide","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"Note that calcN!() needs to have the above argument structure. With L and calcN! in hand we can construct our problem's equation:","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"equation = FourierFlows.Equation(L, calcN!, grid)","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"Last, we have to pick a time-stepper and a time-step dt and gather everything  a FourierFlows's Problem:","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"stepper, dt = \"ForwardEuler\", 0.02\n\nprob = FourierFlows.Problem(equation, stepper, dt, grid, vars, params)","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"Currently, the implemented time-steppers are [ForwardEuler]](@ref), [AB3]](@ref) (Adams-Basmforth 3rd order), [RK4]](@ref) (Runge-Kutta 4th order), and [ETDRK4]](@ref) (Exponential Time Differencing Runge-Kutta 4th order). Also, there exist the Filtered versions of all the above, in which a high-wavenumber filter is applied after every time-step.","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"By default, the Problem constructor takes sol a complex valued array same  size as L filed with zeros.","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"The prob.clock contains the time-step dt and the current step and time t of the simulation:","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"prob.clock","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"Let's initiate our problem with, e.g., u(x 0) = cos(pi x), integrate up  to t = 4 and compare our numerical solution with the analytic solution  u(x t) = e^-alpha t cos(pi x).","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"u0 = @. cos(œÄ * grid.x)\n\nusing LinearAlgebra: mul!\n\nmul!(prob.sol, grid.rfftplan, u0)\n\nnothing # hide","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"Since our time-step is chosen dt = 0.02, we need to step forward prob for 200  time-steps to reach t = 4.","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"stepforward!(prob, 200)","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"Now let's transform our state vector sol back in physical space","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"using LinearAlgebra: ldiv!\n\nldiv!(prob.vars.u, grid.rfftplan, prob.sol)\n\nnothing # hide","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"and finally, let's plot our solution and compare with the analytic solution:","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"using Plots, Printf\n\nplot(grid.x, prob.vars.u,\n     seriestype = :scatter,\n          label = \"numerical\",\n         xlabel = \"x\",\n          title = @sprintf(\"u(x, t=%1.2f)\", prob.clock.t))\n\nplot!(x -> cos(œÄ * x) * exp(-prob.params.Œ± * 4), -1, 1, label=\"analytical\")\n\nplot!(x -> cos(œÄ * x), -1, 1, linestyle=:dash, color=:gray, label=\"initial condition\")\n\nsavefig(\"assets/plot5.svg\"); nothing # hide","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"(Image: )","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"A good practice is to encompass all functions and type definitions related with a PDE under  a single module, e.g.,","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"module MyPDE\n\n  ...\n\nend # end module","category":"page"},{"location":"problem/","page":"Problem","title":"Problem","text":"For a more elaborate example we urge you to have a look at the Diffusion  module located at src/diffusion.jl and also the modules included in the child package GeophysicalFlows.jl.","category":"page"},{"location":"gpu/#GPU","page":"GPU","title":"GPU","text":"","category":"section"},{"location":"gpu/","page":"GPU","title":"GPU","text":"FourierFlows allows you to easily construct and run problems on GPUs.","category":"page"},{"location":"gpu/","page":"GPU","title":"GPU","text":"Upon calling","category":"page"},{"location":"gpu/","page":"GPU","title":"GPU","text":"using FourierFlows","category":"page"},{"location":"gpu/","page":"GPU","title":"GPU","text":"FourierFlows.jl will check whether any CUDA enabled device is present. If such a device is  found then FourierFlows.jl makes sure that CUDA related packages are loaded and also it will  overload all methods to work with GPU() device as their argument (instead of the standard  CPU() device).","category":"page"},{"location":"gpu/","page":"GPU","title":"GPU","text":"It's easy to construct a grid that lives on the GPU. Calling:","category":"page"},{"location":"gpu/","page":"GPU","title":"GPU","text":"dev = GPU()\nn, L = 16, 2.0\ngrid = OneDGrid(dev, n, L)\n\nOneDimensionalGrid\n  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Device: GPU\n  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FloatType: Float64\n  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ size Lx: 2.0\n  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ resolution nx: 16\n  ‚îú‚îÄ‚îÄ grid spacing dx: 0.125\n  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ domain: x ‚àà [-1.0, 0.875]\n  ‚îî‚îÄ aliased fraction: 0.3333333333333333","category":"page"},{"location":"gpu/","page":"GPU","title":"GPU","text":"gives out a grid whose arrays are CuArrays. (Calling OneDGrid(n, L) defaults to CPU, i.e.,  OneDGrid(CPU(), n, L).)","category":"page"},{"location":"gpu/","page":"GPU","title":"GPU","text":"When we construct the Params, Vars, and Equation for our problem we need to make sure that we create arrays on the appropriate device, i.e., Arrays for CPU or CuArrays for the GPU. Function ArrayType is useful in constructing appropriately chosen arrays.","category":"page"},{"location":"gpu/","page":"GPU","title":"GPU","text":"ArrayType","category":"page"},{"location":"gpu/#FourierFlows.ArrayType","page":"GPU","title":"FourierFlows.ArrayType","text":"ArrayType(::Device)\nArrayType(::Device, T, dim)\n\nReturns the proper array type according to the Device chosen, i.e., Array for CPU and CuArray for GPU.\n\n\n\n\n\n","category":"function"},{"location":"gpu/","page":"GPU","title":"GPU","text":"The FourierFlows.Problem constructor then takes an optional positional argument  dev::Device. If not provided anything, the default values for dev=CPU().","category":"page"},{"location":"gpu/","page":"GPU","title":"GPU","text":"problem = Problem(equation, stepper, dt, grid, vars, params, GPU())","category":"page"},{"location":"gpu/","page":"GPU","title":"GPU","text":"The FourierFlows.Diffusion module is written in a way such that switching from CPU to GPU  is only a matter of calling FourierFlows.Diffusion.Problem() with dev=GPU(). All physics  modules in GeophysicalFlows.jl can  also seamlessly run on a GPU with dev=GPU() argument.","category":"page"},{"location":"gpu/#Selecting-GPU-device","page":"GPU","title":"Selecting GPU device","text":"","category":"section"},{"location":"gpu/","page":"GPU","title":"GPU","text":"FourierFlows.jl can only utilize a single GPU. If your machine has more than one GPU available,  then functionality within CUDA.jl package enables the user to choose the GPU device that  FourierFlows.jl should use. The user is referred to the CUDA.jl Documentation; in particular, CUDA.devices and CUDA.CuDevice.","category":"page"},{"location":"#FourierFlows.jl-Documentation","page":"Home","title":"FourierFlows.jl Documentation","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"FourierFlows provides a framework to write solvers for partial differential equations on periodic domains with Fourier-based pseudospectral methods that run seamlessly on CPUs and GPUs. We support 1-, 2-, and 3-dimensional domains.","category":"page"},{"location":"","page":"Home","title":"Home","text":"At the moment we have a lot of modules for solving PDEs related geophysical settings but it's easy to generalize to other PDEs.","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"An example demonstrating how to code up and solve the linear shallow water equations is found in the Examples section of the documentation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more examples of FourierFlows.jl in action, see the child packages GeophysicalFlows.jl or PassiveTracerFlows.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"info: Unicode\nOftentimes unicode symbols appear in modules for variables or parameters. For example, Œ∫ appears as the diffusivity in the Diffusion module. Unicode symbols can be entered  in the Julia REPL by typing, e.g., \\kappa followed by tab key. Read more about Unicode  symbols in the Julia Documentation.","category":"page"},{"location":"#Developers","page":"Home","title":"Developers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"FourierFlows is currently being developed by Gregory L. Wagner and  Navid C. Constantinou.","category":"page"},{"location":"#Cite","page":"Home","title":"Cite","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The code is citable via zenodo.","category":"page"},{"location":"library/public/#Public-Documentation","page":"Public","title":"Public Documentation","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Documentation for FourierFlows.jl's public interface.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"See the Internals section of the manual for internal package docs covering all submodules.","category":"page"},{"location":"library/public/#FourierFlows","page":"Public","title":"FourierFlows","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [FourierFlows]\nPrivate = false\nPages   = [\"FourierFlows.jl\"]","category":"page"},{"location":"library/public/#FourierFlows.FourierFlows","page":"Public","title":"FourierFlows.FourierFlows","text":"Main module for FourierFlows.jl ‚Äì an ecosystem for solving partial differential equations  on periodic domains using Fourier-based pseudospectral methods.\"\n\nExports\n\nAB3TimeStepper\nAbstractGrid\nAbstractParams\nAbstractTimeStepper\nAbstractVars\nArrayType\nCPU\nDevice\nDiagnostic\nETDRK4TimeStepper\nFilteredAB3TimeStepper\nFilteredETDRK4TimeStepper\nFilteredForwardEulerTimeStepper\nFilteredRK4TimeStepper\nForwardEulerTimeStepper\nGPU\nOneDGrid\nOutput\nRK4TimeStepper\nThreeDGrid\nTimeStepper\nTwoDGrid\nZeroDGrid\n@createarrays\ncxtype\ndealias!\n@devzeros\ndevzeros\nfft\nfltype\ngridpoints\ngroupsize\nifft\nincrement!\ninnereltype\nirfft\nresize!\nrfft\nsavediagnostic\nsaveoutput\nsaveproblem\nstep_until!\nstepforward!\nsupersize\n@superzeros\nsuperzeros\nupdate!\n@zeros\n\n\n\n\n\n","category":"module"},{"location":"library/public/#FourierFlows.AbstractGrid","page":"Public","title":"FourierFlows.AbstractGrid","text":"Abstract supertype for grids.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.AbstractParams","page":"Public","title":"FourierFlows.AbstractParams","text":"Abstract supertype for parameters.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.AbstractTimeStepper","page":"Public","title":"FourierFlows.AbstractTimeStepper","text":"Abstract supertype for timesteppers.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.AbstractVars","page":"Public","title":"FourierFlows.AbstractVars","text":"Abstract supertype for variables.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.CPU","page":"Public","title":"FourierFlows.CPU","text":"CPU device.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.Device","page":"Public","title":"FourierFlows.Device","text":"Abstract supertype for device.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.GPU","page":"Public","title":"FourierFlows.GPU","text":"GPU device.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#Problem","page":"Public","title":"Problem","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [FourierFlows]\nPrivate = false\nPages   = [\"problem.jl\"]","category":"page"},{"location":"library/public/#Domain","page":"Public","title":"Domain","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [FourierFlows]\nPrivate = false\nPages   = [\"domains.jl\"]","category":"page"},{"location":"library/public/#FourierFlows.OneDGrid","page":"Public","title":"FourierFlows.OneDGrid","text":"struct OneDGrid{T<:AbstractFloat, Tk, Tx, Tfft, Trfft, Talias} <: AbstractGrid{T, Tk, Talias}\n\nA one-dimensional grid.\n\nnx::Int64\nnumber of points in x\nnk::Int64\nnumber of wavenumbers in x\nnkr::Int64\nnumber of positive wavenumbers in x (real Fourier transforms)\ndx::AbstractFloat\ngrid spacing in x\nLx::AbstractFloat\ndomain extent in x\nx::Any\nrange with x-grid-points\nk::Any\narray with x-wavenumbers\nkr::Any\narray with positive x-wavenumbers (real Fourier transforms)\ninvksq::Any\narray with inverse squared k-wavenumbers, 1/k¬≤\ninvkrsq::Any\narray with inverse squared kr-wavenumbers, 1/kr¬≤\nfftplan::Any\nthe FFT plan for complex-valued fields\nrfftplan::Any\nthe FFT plan for real-valued fields\naliased_fraction::AbstractFloat\nthe fraction of wavenumbers that are aliased (e.g., 1/3 for quadradic nonlinearities)\nkalias::Any\nrange of the indices of aliased x-wavenumbers\nkralias::Any\nrange of the indices of aliased positive x-wavenumbers (real Fourier transforms)\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.OneDGrid-Tuple{Any, Any}","page":"Public","title":"FourierFlows.OneDGrid","text":"OneDGrid(nx, Lx; x0=-Lx/2, nthreads=Sys.CPU_THREADS, effort=FFTW.MEASURE, \n                  T=Float64, aliased_fraction=1/3, ArrayType=Array)\n\nConstructs a OneDGrid object with size Lx, resolution nx, and leftmost position x0.  FFT plans are generated for nthreads CPUs using FFTW flag effort. The float type is T  and the array types is ArrayType. The aliased_fraction keyword determines the highest  wavenubers that are being zero-ed out by dealias! function; 1/3 is the nominal value for  quadratic nonlinearities. \n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.ThreeDGrid","page":"Public","title":"FourierFlows.ThreeDGrid","text":"struct ThreeDGrid{T<:AbstractFloat, Tk, Tx, Tfft, Trfft, Talias} <: AbstractGrid{T, Tk, Talias}\n\nA three-dimensional grid.\n\nnx::Int64\nnumber of points in x\nny::Int64\nnumber of points in y\nnz::Int64\nnumber of points in z\nnk::Int64\nnumber of wavenumbers in x\nnl::Int64\nnumber of wavenumbers in y\nnm::Int64\nnumber of wavenumbers in z\nnkr::Int64\nnumber of positive wavenumers in x (real Fourier transforms)\ndx::AbstractFloat\ngrid spacing in x\ndy::AbstractFloat\ngrid spacing in y\ndz::AbstractFloat\ngrid spacing in z\nLx::AbstractFloat\ndomain extent in x\nLy::AbstractFloat\ndomain extent in y\nLz::AbstractFloat\ndomain extent in z\nx::Any\nrange with x-grid-points\ny::Any\nrange with y-grid-points\nz::Any\nrange with z-grid-points\nk::Any\narray with x-wavenumbers\nl::Any\narray with y-wavenumbers\nm::Any\narray with z-wavenumbers\nkr::Any\narray with positive x-wavenumbers (real Fourier transforms)\nKsq::Any\narray with squared total wavenumbers, k¬≤+l¬≤+m¬≤\ninvKsq::Any\narray with inverse squared total wavenumbers, 1/(k¬≤+l¬≤+m¬≤)\nKrsq::Any\narray with squared total wavenumbers for real Fourier transforms, kr¬≤+l¬≤+m¬≤\ninvKrsq::Any\narray with inverse squared total wavenumbers for real Fourier transforms, 1/(kr¬≤+l¬≤+m¬≤)\nfftplan::Any\nthe FFT plan for complex-valued fields\nrfftplan::Any\nthe FFT plan for real-valued fields\naliased_fraction::AbstractFloat\nthe fraction of wavenumbers that are aliased (e.g., 1/3 for quadradic nonlinearities)\nkalias::Any\nrange of the indices of aliased x-wavenumbers\nkralias::Any\nrange of the indices of aliased positive x-wavenumbers (real Fourier transforms)\nlalias::Any\nrange of the indices of aliased y-wavenumbers\nmalias::Any\nrange of the indices of aliased y-wavenumbers\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.ThreeDGrid-2","page":"Public","title":"FourierFlows.ThreeDGrid","text":"ThreeDGrid(nx, Lx, ny=nx, Ly=Lx, nz=nx, Lz=Lx; x0=-Lx/2, y0=-Ly/2, z0=-Lz/2, \nnthreads=Sys.CPU_THREADS, effort=FFTW.MEASURE, T=Float64, aliased_fraction=1/3, ArrayType=Array)\n\nConstructs a TwoDGrid object with size Lx, Ly, Lz, resolution nx, ny, nz and   leftmost positions x0, y0, z0. FFT plans are generated for nthreads CPUs using FFTW   flag effort. The float type is T and the array types is ArrayType. The aliased_fraction   keyword determines the highest wavenubers that are being zero-ed out by dealias! function;   1/3 is the nominal value for quadratic nonlinearities. \n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.TwoDGrid","page":"Public","title":"FourierFlows.TwoDGrid","text":"struct TwoDGrid{T<:AbstractFloat, Tk, Tx, Tfft, Trfft, Talias} <: AbstractGrid{T, Tk, Talias}\n\nA two-dimensional grid.\n\nnx::Int64\nnumber of points in x\nny::Int64\nnumber of points in y\nnk::Int64\nnumber of wavenumbers in x\nnl::Int64\nnumber of wavenumbers in y\nnkr::Int64\nnumber of positive wavenumers in x (real Fourier transforms)\ndx::AbstractFloat\ngrid spacing in x\ndy::AbstractFloat\ngrid spacing in y\nLx::AbstractFloat\ndomain extent in x\nLy::AbstractFloat\ndomain extent in y\nx::Any\nrange with x-grid-points\ny::Any\nrange with y-grid-points\nk::Any\narray with x-wavenumbers\nl::Any\narray with y-wavenumbers\nkr::Any\narray with positive x-wavenumbers (real Fourier transforms)\nKsq::Any\narray with squared total wavenumbers, k¬≤+l¬≤\ninvKsq::Any\narray with inverse squared total wavenumbers, 1/(k¬≤+l¬≤)\nKrsq::Any\narray with squared total wavenumbers for real Fourier transforms, kr¬≤+l¬≤\ninvKrsq::Any\narray with inverse squared total wavenumbers for real Fourier transforms, 1/(kr¬≤+l¬≤)\nfftplan::Any\nthe FFT plan for complex-valued fields\nrfftplan::Any\nthe FFT plan for real-valued fields\naliased_fraction::AbstractFloat\nthe fraction of wavenumbers that are aliased (e.g., 1/3 for quadradic nonlinearities)\nkalias::Any\nrange of the indices of aliased x-wavenumbers\nkralias::Any\nrange of the indices of aliased positive x-wavenumbers (real Fourier transforms)\nlalias::Any\nrange of the indices of aliased y-wavenumbers\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.TwoDGrid-2","page":"Public","title":"FourierFlows.TwoDGrid","text":"TwoDGrid(nx, Lx, ny=nx, Ly=Lx; x0=-Lx/2, y0=-Ly/2, nthreads=Sys.CPU_THREADS, \n                  effort=FFTW.MEASURE, T=Float64, aliased_fraction=1/3, ArrayType=Array)\n\nConstructs a TwoDGrid object with size Lx, Ly, resolution nx, ny, and leftmost positions x0, y0. FFT plans are generated for nthreads CPUs using FFTW flag effort.  The float type is T and the array types is ArrayType. The aliased_fraction keyword  determines the highest wavenubers that are being zero-ed out by dealias! function; 1/3 is  the nominal value for quadratic nonlinearities. \n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.ZeroDGrid","page":"Public","title":"FourierFlows.ZeroDGrid","text":"A placeholder grid object for 0D problems (in other words, systems of ODEs).\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.dealias!-Tuple{Any, Any}","page":"Public","title":"FourierFlows.dealias!","text":"dealias!(fh, grid)\n\nDealias array fh on the grid based on the grids's aliased_factor.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.gridpoints-Union{Tuple{TwoDGrid{T, A, Tx, Tfft, Trfft, Talias} where {Tx, Tfft, Trfft, Talias}}, Tuple{A}, Tuple{T}} where {T, A}","page":"Public","title":"FourierFlows.gridpoints","text":"gridpoints(grid::TwoDGrid)\ngridpoints(grid::ThreeDGrid)\n\nReturns the collocation points of the grid in 2D or 3D arrays X, Y (and Z).\n\n\n\n\n\n","category":"method"},{"location":"library/public/#Utilities","page":"Public","title":"Utilities","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [FourierFlows]\nPrivate = false\nPages   = [\"utils.jl\"]","category":"page"},{"location":"library/public/#FourierFlows.ArrayType-Tuple{CPU}","page":"Public","title":"FourierFlows.ArrayType","text":"ArrayType(::Device)\nArrayType(::Device, T, dim)\n\nReturns the proper array type according to the Device chosen, i.e., Array for CPU and CuArray for GPU.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.cxtype-Union{Tuple{Type{T}}, Tuple{T}} where T<:Number","page":"Public","title":"FourierFlows.cxtype","text":"cxtype(T)\n\nReturns T when T is Complex, or Complex{T} when T is Real.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.devzeros-Tuple{Any, Any, Any}","page":"Public","title":"FourierFlows.devzeros","text":"devzeros(dev, T, dims)\n\nReturns an array like A of type T, but full of zeros.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.fltype-Union{Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Public","title":"FourierFlows.fltype","text":"fltype(T)\n\nReturns T when T<:AbstractFloat or Tf when T<:Complex{Tf}.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.innereltype-Tuple{Any}","page":"Public","title":"FourierFlows.innereltype","text":"innereltype(x)\n\nRecursively determine the 'innermost' type in by the collection x (which may be, for example, a collection of a collection).\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.superzeros-Tuple{Any, AbstractArray}","page":"Public","title":"FourierFlows.superzeros","text":"superzeros(T, A)\n\nReturns an array like A, but full of zeros. If innereltype(A) can be promoted to T, then the innermost elements of the array will have type T.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.@devzeros-Tuple{Any, Any, Any, Vararg{Any, N} where N}","page":"Public","title":"FourierFlows.@devzeros","text":"@devzeros dev T dims a b c...\n\nCreate arrays of all zeros with element type T, size dims, and global names a, b, c (for example) on device dev.\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#FourierFlows.@superzeros-Tuple{Any, Any, Vararg{Any, N} where N}","page":"Public","title":"FourierFlows.@superzeros","text":"@superzeros T a b c d...\n@superzeros T dims b c d...\n\nGenerate arrays b, c, d... with the super-dimensions of a and innereltype T.\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#FourierFlows.@zeros-Tuple{Any, Any, Vararg{Any, N} where N}","page":"Public","title":"FourierFlows.@zeros","text":"@zeros T dims a b c...\n\nCreate arrays of all zeros with element type T, size dims, and global names a, b, c (for example). An arbitrary number of arrays may be created.\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#Diagnostics","page":"Public","title":"Diagnostics","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [FourierFlows]\nPrivate = false\nPages   = [\"diagnostics.jl\"]","category":"page"},{"location":"library/public/#FourierFlows.Diagnostic","page":"Public","title":"FourierFlows.Diagnostic","text":"mutable struct Diagnostic{T, N} <: AbstractDiagnostic\n\nA diagnostic that includes N elements of type T.\n\ncalc::Function\nfunction that returns the diagnostic via calc(prob)\nprob::FourierFlows.Problem\nthe relevant problem for this diagnostic\ndata::Vector{T} where T\nvector where the diagnostic time-series is saved\nt::Vector{Float64}\nvector with the times for which the diagnostic was saved\nsteps::Vector{Int64}\nvector with the problem's step for which the diagnostic was saved\nfreq::Int64\ninteger denoting how often (every how many problem.steps) to save the diagnostic\ni::Int64\ninteger denoting how many times the diagnostic.data was updated\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.Diagnostic-Tuple{Any, Any}","page":"Public","title":"FourierFlows.Diagnostic","text":"Diagnostic(calc, prob; freq=1, nsteps=100, ndata=ceil(Int, (nsteps+1)/freq))\n\nConstruct a diagnostic that stores the result of calc(prob) with frequency freq.\n\nKeywords\n\nfreq: Diagnostic is saved every freq steps.\nnsteps: The total number of steps in problem.\nndata: The number of diagnostics to be saved.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.increment!-Tuple{Any}","page":"Public","title":"FourierFlows.increment!","text":"increment!(diag)\n\nIncrement the Diagnostic diag, or an array of Diagnostics diags.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.update!-Tuple{Any, Any}","page":"Public","title":"FourierFlows.update!","text":"update!(diag)\n\nUpdate diag.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#Output","page":"Public","title":"Output","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [FourierFlows]\nPrivate = false\nPages   = [\"output.jl\"]","category":"page"},{"location":"library/public/#FourierFlows.Output","page":"Public","title":"FourierFlows.Output","text":"struct Output\n\nThe composite type for output.\n\nprob::FourierFlows.Problem\nthe relevant problem for the output\npath::String\nthe path for the output file\nfields::Dict{Symbol, Function}\nthe fields to be saved; the relevant problem for this diagnostic\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.Output-Tuple{Any, Any, Dict{Symbol, Function}}","page":"Public","title":"FourierFlows.Output","text":"Output(prob, filename, fieldtuples...)\n\nDefine output for prob with fields and functions that calculate the output in the list of tuples fieldtuples = (fldname, func)....\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.savediagnostic-Tuple{Any, Any, Any}","page":"Public","title":"FourierFlows.savediagnostic","text":"savediagnostic(diag, diagname, filename)\n\nSave diagnostics in diag to filename, labeled by diagname.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.saveoutput-Tuple{Any}","page":"Public","title":"FourierFlows.saveoutput","text":"saveoutput(out)\n\nSave the fields in out.fields to out.path.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.saveproblem-Tuple{Any, Any}","page":"Public","title":"FourierFlows.saveproblem","text":"saveproblem(prob, filename)\n\nSave certain aspects of a problem prob to filename.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#Timesteppers","page":"Public","title":"Timesteppers","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [FourierFlows]\nPrivate = false\nPages   = [\"timesteppers.jl\"]","category":"page"},{"location":"library/public/#FourierFlows.AB3TimeStepper","page":"Public","title":"FourierFlows.AB3TimeStepper","text":"AB3TimeStepper{T} <: AbstractTimeStepper{T}\n\nType for 3rd order Adams-Bashforth time-stepper.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.AB3TimeStepper-2","page":"Public","title":"FourierFlows.AB3TimeStepper","text":"FilteredAB3TimeStepper(equation, dev; filterkwargs...)\n\nConstruct a 3rd order Adams-Bashforth time stepper.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.ETDRK4TimeStepper","page":"Public","title":"FourierFlows.ETDRK4TimeStepper","text":"ETDRK4TimeStepper{T,TL} <: AbstractTimeStepper{T}\n\nType for 4th-order exponential-time-differencing Runge-Kutta time stepper.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.ETDRK4TimeStepper-2","page":"Public","title":"FourierFlows.ETDRK4TimeStepper","text":"ETDRK4TimeStepper(eq::Equation, dt, dev::Device=CPU())\n\nConstruct a 4th-order exponential-time-differencing Runge-Kutta time stepper.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.FilteredAB3TimeStepper","page":"Public","title":"FourierFlows.FilteredAB3TimeStepper","text":"FilteredAB3TimeStepper{T} <: AbstractTimeStepper{T}\n\nType for 3rd order Adams-Bashforth time-stepper with spectral filtering.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.FilteredAB3TimeStepper-2","page":"Public","title":"FourierFlows.FilteredAB3TimeStepper","text":"FilteredAB3TimeStepper(equation, dev; filterkwargs...)\n\nConstruct a 3rd order Adams-Bashforth time stepper with spectral filtering.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.FilteredETDRK4TimeStepper","page":"Public","title":"FourierFlows.FilteredETDRK4TimeStepper","text":"FilteredETDRK4TimeStepper{T,TL,Tf} <: AbstractTimeStepper{T}\n\nType for 4th-order exponential-time-differencing Runge-Kutta time stepper with spectral filtering.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.FilteredETDRK4TimeStepper-2","page":"Public","title":"FourierFlows.FilteredETDRK4TimeStepper","text":"FilteredETDRK4TimeStepper(equation, dt; filterkwargs...)\n\nConstruct a 4th-order exponential-time-differencing Runge-Kutta time stepper with spectral filtering.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.FilteredForwardEulerTimeStepper","page":"Public","title":"FourierFlows.FilteredForwardEulerTimeStepper","text":"FilteredForwardEulerTimeStepper(eq, dev; filterkwargs...)\n\nType for Forward Euler timestepper with spectral filtering.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.FilteredForwardEulerTimeStepper-2","page":"Public","title":"FourierFlows.FilteredForwardEulerTimeStepper","text":"FilteredForwardEulerTimeStepper(eq, dev; filterkwargs...)\n\nConstruct a forward Euler timestepper with spectral filtering.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.FilteredRK4TimeStepper","page":"Public","title":"FourierFlows.FilteredRK4TimeStepper","text":"FilteredRK4TimeStepper{T,Tf} <: AbstractTimeStepper{T}\n\nType for 4th-order Runge-Kutta time stepper with spectral filtering for the equation eq.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.FilteredRK4TimeStepper-2","page":"Public","title":"FourierFlows.FilteredRK4TimeStepper","text":"FilteredRK4TimeStepper(eq::Equation, dev::Device=CPU(); filterkwargs...)\n\nConstruct a 4th-order Runge-Kutta time stepper with spectral filtering for the equation eq.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.ForwardEulerTimeStepper","page":"Public","title":"FourierFlows.ForwardEulerTimeStepper","text":"ForwardEulerTimeStepper{T} <: AbstractTimeStepper{T}\n\nType for Forward Euler timestepper.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.ForwardEulerTimeStepper-2","page":"Public","title":"FourierFlows.ForwardEulerTimeStepper","text":"ForwardEulerTimeStepper(eq::Equation, dev::Device=CPU())\n\nConstruct a Forward Euler timestepper.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.RK4TimeStepper","page":"Public","title":"FourierFlows.RK4TimeStepper","text":"RK4TimeStepper{T} <: AbstractTimeStepper{T}\n\nType for 4th-order Runge-Kutta time stepper for the equation eq.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.RK4TimeStepper-2","page":"Public","title":"FourierFlows.RK4TimeStepper","text":"RK4TimeStepper(eq::Equation, dev::Device=CPU())\n\nConstruct a 4th-order Runge-Kutta time stepper for the equation eq.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#FourierFlows.TimeStepper","page":"Public","title":"FourierFlows.TimeStepper","text":"TimeStepper(stepper, equation, dt=nothing, dev=CPU(); kw...)\n\nInstantiate the Timestepper for equation with timestep dt and on the device. The kw are passed to the timestepper constructor.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#FourierFlows.step_until!-Tuple{Any, Any}","page":"Public","title":"FourierFlows.step_until!","text":"step_until!(prob, stop_time)\n\nStep forward prob until stop_time. Cannot be used with ETDRK4 time steppers.\n\nSee also: stepforward!\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.stepforward!-Tuple{FourierFlows.Problem, Any, Int64}","page":"Public","title":"FourierFlows.stepforward!","text":"stepforward!(prob::Problem, diags, nsteps::Int)\n\nStep forward prob for nsteps, incrementing diags along the way. diags may be a  single Diagnostic or a Vector of Diagnostics.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.stepforward!-Tuple{FourierFlows.Problem, Int64}","page":"Public","title":"FourierFlows.stepforward!","text":"stepforward!(prob, nsteps::Int)\n\nStep forward prob for nsteps.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.stepforward!-Tuple{FourierFlows.Problem}","page":"Public","title":"FourierFlows.stepforward!","text":"stepforward!(prob)\n\nStep forward prob one time step.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#Diffusion-Testbed-Module","page":"Public","title":"Diffusion Testbed Module","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [FourierFlows.Diffusion]\nPrivate = false\nPages   = [\"diffusion.jl\"]","category":"page"},{"location":"library/public/#FourierFlows.Diffusion","page":"Public","title":"FourierFlows.Diffusion","text":"A test-bed module that solves the 1D diffusion equation.\n\nExports\n\nProblem\nset_c!\nupdatevars!\n\n\n\n\n\n","category":"module"},{"location":"library/public/#FourierFlows.Diffusion.Problem","page":"Public","title":"FourierFlows.Diffusion.Problem","text":"Problem(dev::Device = CPU();\n                 nx = 128,\n                 Lx = 2œÄ,\n                  Œ∫ = 0,\n                 dt = 0.01,\n            stepper = \"RK4\",           \n   aliased_fraction = 0,\n                  T = Float64)\n\nConstruct a constant diffusivity problem.\n\nKeyword arguments\n\ndev: (required) CPU() or GPU(); computer architecture used to time-step problem.\nnx: Number of grid points in x-domain.\nLx: Extent of the x-domain.\nŒ∫: Diffusivity coefficient.\ndt: Time-step.\nstepper: The extent of the y-domain.\naliased_fraction: the fraction of high-wavenubers that are zero-ed out by dealias!().\nT: Float64 or Float32; floating point type used for problem data.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#FourierFlows.Diffusion.set_c!-Tuple{Any, Any}","page":"Public","title":"FourierFlows.Diffusion.set_c!","text":"set_c!(prob, c)\n\nSet the solution sol as the transform of c and update vars.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#FourierFlows.Diffusion.updatevars!-Tuple{Any, Any, Any}","page":"Public","title":"FourierFlows.Diffusion.updatevars!","text":"updatevars!(vars, grid, sol)\n\nUpdate the variables in vars on the grid with the solution in sol.\n\n\n\n\n\n","category":"method"}]
}
